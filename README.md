# HELML

## HELML (Header-Like Markup Language)

HELML (HEader-Like Markup Language) - это язык разметки, похожий на формат заголовков HTTP.

Например, этот текст в формате HELML:

```console
Host: github.com
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:109.0) Gecko/20100101 Firefox/110.0
Accept: image/avif,image/webp,*/*
Accept-Language: ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br
Referer: https://github.com/dynoser/HELML/README.md
```
Если декодировать этот текст через HELML.decode, получится массив `[ключ] => 'значение'`, примерно так:
```console
[
    'Host' => 'github.com',
    'User-Agent' => 'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:109.0) Gecko/20100101 Firefox/110.0',
...
]
```

# Пустые строки и комментарии

- Пустые строки игнорируются.
- Строки-комментарии начинаются со знака "`#`".
- Внутри строк комментарии не предусмотрены, закомментировать можно только всю строку.

> 
    Вы можете добавлять сколько угодно пустых строк где угодно, они не важны.
    Вы можете закомментировать какие-то строки поставив # в начале строки.



# Вложенные массивы

## Формат HELML поддерживает массивы любой структуры, без ограничений уровня вложенности.

### Структурой массива управляет символ двоеточие "`:`".

Это ключевой момент, рассмотрим его подробнее. Начнём с примера.

Закодируем в HELML этот массив:
```console
[
    'Host' => 'github.com',
    'Names' => [
        'no_www' => 'github.com',
        'www' => 'www.github.com
    ],
    'Test' => 'The test'
]
```
Результат:
```console
Host: github.com
Names
:no_www: github.com
:www: www.github.com
Test: The test

```
## Как работает двоеточие "`:`"

Двоеточие - единственный символ, кроме разделителя строк, который управляет структурой массива.

1. Количество двоеточий в начале строки задаёт уровень вложенности. Назовём это "**двоеточия уровня**".
2. Следующее двоеточие либо отсутствует, либо присутствует. Назовём его "**разбивающее двоеточие**".

Если "**двоеточия уровня**" в начале строки отсутствуют, то значит они присуствуют в количестве 0.


- Если "разбивающее двоеточие" есть, то оно разбивает строку на "ключ" и "значение".
- Если же "разбивающее двоеточие" отсутствует, то это означает создание вложенного массива.

> 
    В приведённом выше примере строка "Names" без двоеточий означает, что
    "двоеточия уровня" в ней присутствуют в количестве 0,
    а "разбивающее двоеточие" - отсутствует.
    В итоге эта строка означает создание под-массива в ключе с именем [Names].

## Другой пример. Более глубокая вложенность

Закодируем в HELML такой массив:
```console
[
    'A' => 123,
    'B' => [
        'X' => 456,
        'Y' => 789,
        'Z' => [
            'One' => 1,
            'Two' => 2
        ]
        'C' => 888
    ],
    'D' => 111
]
```

Результат:
```console
A: 123
B
:X: 456
:Y: 789
:Z
::One: 1
::Two: 2
:C: 888
D: 111
```

# Некоторые нюансы управления вложенностью

У вас могут возникнуть вопросы: а что будет, если написать, например, так:

```console
A: 123
:B: 456
::C: 789
```
- Вопрос: Куда попадут B и C ?
- Ответ: Они попадут туда же, куда и A, то есть в корневой уровень массива.
- Почему?
> 
    Потому что в этом примере нет создания под-массивов.
    Увеличение количества "двоеточий уровня" не влечёт создание под-массивов.
    Создание под-массивов должно быть явным.
    Иными словами, если количество "двоеточий уровня" больше, чем
     текущий уровень вложенности, то это не имеет значения.

    А вот если меньше - тогда это имеет значение.
    
    Фактически, количество "двоеточий уровня" говорит о том,
    возвращаемся ли мы на назад, на предыдущие уровни вложенности.
    Если количество "двоеточий уровня" меньше, чем текущий уровень вложенности,
    тогда мы возвращаемся назад, на тот уровень, который будет им соответствовать.


Выше мы описали всё, что касается управления структурой вложенности массивов.

Теперь перейдём к рассмотрению кодировки значений.



# Кодировка значений

- в простых случаях, которых большинство, значения кодируются так, как мы рассматривали выше.
  
> 
    Простые случаи - это значение подходит для простой подстановки в формат "ключ: значение".

    Особые случаи - когда значение особенное (например, бинарное), или если важно указать его тип.

    Например, если значение начинается с пробела, содержит не-печатные знаки так далее.

- значение всегда может быть представлено в кодировке Base64 (а также Base64url)

>
    Если пробел после "разбивающего двоеточия" отсутствует, то значение предполагается закодированным в Base64.
    Эти две строки эквивалентны:

    A: Test
    A:IFRlc3Q=
    # в данном случае "IFRlc3Q=" является строкой "Test" в кодировке Base64, а пробел отсутствует.

! Количество пробелов после "разбивающего двоеточия" важно,
  оно указывает на особые случаи кодировки значения.

- Если между "разбивающим двоеточием" и значением стоит один пробел, это "простой случай".
- Если пробела нет, или пробелов два и более, это "особые случаи".
- Если пробела нет, то:
  - если значение начинается на двойные или одинарные кавычки, это "случаи кавычек".
    - если кавычки одинарные, то возвращается значение внутри них, а кавычки отбрасываются.
    - если кавычки двойные, то возвращается значение с парсингом спец-символов (таких как `"\n"`)
  - если это не кавычки, то значение предполагается закодированным в Base64 (или Base64url)
    - если это значение будет успешно раскодировано из Base64, будет возвращено раскодированное значение.
    - если не удаётся раскодировать, то значение будет возвращено как есть (не рекомендуемый сценарий!)
- Если пробелов два, то это касается случаев строгой типизации:
  - если после двух пробелов следует число, то оно будет представлено как число, а не как строка.
    - если число содержит в себе точку, оно будет представлено как float
    - если число не содержит точку, оно будет представлено как integer
  - если после двух пробелов следует:
    - T - будет представлено как boolean-значение True
    - F - будет представлено как boolean-значение False
    - N - будет представлено как "отсутствие" NULL, или None, в зависимости от языка результата

>
    Например, в зависимости от количества пробелов, 123 будет представлено как число, или как строка:
    A: 123   -- если один пробел, значит 123 будет возвращено как строка
    A:  123  -- если два пробела, значит 123 будет возвращено как число integer
    
Вариант с указанием строки в кавычках имеет смысл тогда, когда:
  - когда в значении важны пробелы по краям
  - когда мы явно хотим указать пустую строку, избегая какой-либо неоднозначности понимания
  - двойные кавычки позволяют указать спец.символы в слэш-формате, не упаковывая значение в Base64

>
    # явное указание пустой строки в качестве значения:
    Test:""

    # здесь пробелы в начале и конце строки будут сохранены, а кавычки отброшены:
    Hello:"  Hello World "

    # здесь результат будет точно такой же, как в предыдущем варианте:
    Hello:'  Hello World '

    # здесь значением будет строка вместе с кавычками, кавычки не будут отброшены.
    # потому что пробел после двоеточия указывает на "простой случай", и данные возвращаются "как есть":
    Hello: " Hello World "

    # Здесь значение будет с символом перевода строки внутри, а двойные кавычки будут отброшены:
    Hello:"  Hello\n World  "

    # Здесь значение "\n" не будет преобразовано в символ перевода строки, данные вернутся как есть, без кавычек:
    Hello:'  Hello\n World  '



# Кодировка ключей

- Есть только два варианта кодировки ключей:
  1) либо просто "как есть",
  2) либо закодировано в Base64 (Base64url)
  
Признаком того, что ключ закодирован в Base64 является наличие знака "-" в начале.

Например:
>
    ABC: Test      -- то же самое, что и строка ниже
    -QUJD: Test    -- здесь "QUJD" это "ABC" в кодировке Base64, а знак "-" признак закодированности.


# Повторяющиеся ключи

> 
    Q: -Что будет если один и тот же ключ встречается несколько раз?
    A: -Следующий ключ заменит предыдущий.

Теоретически, можно бы было сделать возможность "дописывать" элементы к заданным ранее массивам.
Однако, такой подход создавал бы простор для неоднозначной трактовки кода.
Поэтому, по крайней мере в текущей реализации, повторное появление ключа всегда влечёт его перезапись.
Старое значение полностью забывается и заменяется на новое.
Например, в этом коде сначала задаётся массива A, и затем заменяется строковым значением "Three".
```console
A
:1:One
:2:Two
A: Three
```
Предполагается, что повторные ключи - результат ручного редактирования.
Либо это ошибка, либо это для того, чтобы отменить данные, описанные выше, вместо того чтобы их закомментировать.


# Итоги

Формат HELML позволяет кодировать массивы сколь угодно сложной структуры
и затем раскодировать их с сохранением оснвоных типов данных (true, false, null, integer)
Этот формат идеологически близок к YAML, JSON, и других форматам сериализации массивов,
и предназначен для использования вместо них в некоторых случаях, когда это более удобно.

Основным преимуществом формата HELML является его простота и минимализм.
Формат работает с любыми данными, не спотыкается на бинарных блоках и спецсимволах.
В то же время формат интуитивно понятен, может создаваться и редактироваться вручную.
В большинстве случаев данные в HELML будут компактнее, чем в других языках разметки.


# URL-режим

Заменияем разделители строк на "~", управляющие двоеточия на точки ".", управляющие пробелы на нижнее подчёркивание "_",
и получаем одну строку, которая легко может быть использована как GET-параметр для URL, или как аргумент командной строки.
В таком виде HELML-формат визуально менее понятен, чем в многострочном формате, но зато очень компактно преобраозвывается "urlencode".
Выбор символов для замены обусловлен тем, что преобразование "urlencode" (RFC 3986) их не изменяет.
Возможно, это простейший способ передать в одной строке URL произвольный массив с сохранением его структуры и типизацией данных.
