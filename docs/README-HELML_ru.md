# HELML

## HELML (Header-Like Markup Language)

![helml-logo](https://raw.githubusercontent.com/dynoser/HELML/master/logo/icon.png)

HELML (HEader-Like Markup Language) - это язык разметки, похожий на формат заголовков HTTP.

[Спецификация HELML](https://github.com/dynoser/HELML/blob/master/docs/HELML_ru.md)

Например, можно этот текст декодировать из HELML:
```sh
Host: github.com
Accept: image/avif,image/webp
Accept-Encoding: gzip, deflate, br
```
В результате получится массив `[ключ] => 'значение'`:
```json
{
	"Host": "github.com",
	"Accept": "image/avif,image/webp",
	"Accept-Encoding": "gzip, deflate, br"
}
```
HELML позволяет создавать вложенные массивы, управляя вложенностью знаками "`:`", например:

```sh
Hosts:
 :--: github.com
 :--: www.github.com
```
В формате JSON это будет так:
```json
{
	"Hosts": [
		"github.com",
		"www.github.com"
	]
}
```
# Зачем?

I. Когда не справляется JSON

  - Если нужна сериализация массивов, в которых встречаются бинарные данные, то
стандартный упаковщик JSON будет "спотыкаться", а HELML работает с любыми данными.

  - стандартный JSON не понимает комментарии. Иногда их очень не хватает.

II. Минимализм

  - Когда ищешь альтернативу JSON, выясняется, что большинство парсеров громоздкие, и тянуть
их в свой проект для простейших задач не рационально.

  - Алгоритмы кодирования/декодирования HELML простые, короткие и быстрые.

III. Возможность выборочного парсинга

  Из файла HELML можно легко выбирать только нужные секции и игнорировать всё остальное.
  Это позволяет заметно ускорить выборку нужных данных из большого массива в HELML-файле,
  не теряя время на неинтересные в данный момент данные и не занимая этими данными память.

IV. Концепция многослойности

* Не смотря на свою простоту, HELML поддерживает концепцию многослойности, что может быть полезно.
* см. ["многослойные массивы"](https://github.com/dynoser/HELML/blob/master/docs/MultiLayerArrays_ru.md)

# HELML это просто

Во многих случаях данные в формате HELML можно записывать не подключая
никакого кодировщика, просто выводя строки данных в виде "ключ: значение".

Кодирование и декодирование HELML выполняется простыми алгоритмами, они лаконичны на любом языке программирования.

HELML легко создавать и редактировать вручную.

Рассмотрим подробности.

## Пустые строки и комментарии

- Пустые строки игнорируются.
- Пробелы по краям строк игнорируются (обрезаются и не имеют значения)
- Строки, начинающиеся со знака "`#`" игнорируются (считаются комментариями).
- Внутри-строчные комментарии не предусмотрены.

## Использование Base64

Ключи и значения могут быть представлены в кодировке Base64.

Признаком закодированности в base64 является наличие в начале знака "-".

Например, четыре строки ниже в HELML означают одно и то же:

```python
# Простое представление ключ: значение
Host: github.com

# Ключ "Host" закодирован в base64
-SG9zdA: github.com

# Значение "github.com" закодировано в base64
# Обратите внимание, что "-" стоит сразу после двоеточия, без пробела.
Host:-Z2l0aHViLmNvbQ

# Ключ и значение закодированы в base64
-SG9zdA:-Z2l0aHViLmNvbQ
```

# Вложенные массивы

### Вложенностью массивов управляет знак "`:`" слева строки.

Количество двоеточий в начале строки означает целевой уровень вложенности.

Пример. Закодируем это в HELML:

```json
{
	"Host": "github.com",
	"Names": {
		"first name": "github",
		"last name": "com"
	},
	"Family": "repos"
}
```
Результат:
```sh
Host: github.com
Names
 :first name: github
 :last name: com
Family: repos
```
В результате мы видим отступы слева у вложенных элементов.
Эти отступы состоят из пробелов и двоеточий. Пробелы не важны, они добавлены для удобства визуального восприятия.
Двоеточия - важны, они указывают уровень вложенности.

# Роль двоеточий

Двоеточия имеют двойную роль:

- Двоеточия в начале строки управляют структуризацией массивов.
- Двоеточие не-в-начале строки отделяет "ключ" от "значения".

## Объяснения

Двоеточие — это единственный символ, кроме разделителя строк, который управляет структурой массива.

1. Количество двоеточий в начале строки задаёт целевой уровень вложенности. Это "**двоеточия уровня**".
2. За "двоеточиями уровня" всегда следует "**ключ**".
3. Следующее за ключом двоеточие либо отсутствует, либо присутствует. Это "**разделяющее двоеточие**".

Любая строка HELML (кроме пустых и комментариев) имеет ключ и, возможно, что-то ещё.

Строка HELML имеет следующий формат: `[двоеточия уровня]ключ[:[значение]]`

* Заметим, что строка HELML всегда явным образом содержит в себе "ключ".
* Если "значение" в строке не указано, то оно подразумевается пустым.

Если есть "**двоеточия уровня**", то они должны следовать друг за другом без пробелов.
Появление любого иного символа означает завершение "**двоеточий уровня**" и начало "ключа".
Если после "двоеточий уровня" в строке есть ещё двоеточие, то это "**разделяющее двоеточие**",
которое разделяет "ключ" и "значение".

Если "**двоеточия уровня**" в начале строки отсутствуют, то они присуствуют в количестве 0,
и в таком случае речь идёт о нулевом (корневом) уровне вложенности массива.

Примеры, как парсятся двоеточия:

```python

# три "двоеточия уровня" и нет "разделяющего двоеточия" (ключ X, значение пустое)
:::X

# четыре "двоеточия уровня", затем ключ "X" и "разделяющее двоеточие", далее значение Y
 ::::X:Y

# одно "двоеточие уровня", затем ключ "AAA", затем "разделяющее двоеточие" и значение " BBB:CCC :DDD:"
:AAA: BBB:CCC :DDD:

# ноль "двоеточий уровня", затем ключ "X" и "разделяющее двоеточие", затем значение "Z"
    X:Z

# ноль "двоеточий уровня", затем ключ "This is a key", нет "разделяющего двоеточия" (пустое значение)
This is a key

# одно "двоеточие уровня", далее ключ "--", затем "разделяющее двоеточие", затем пустое значение.
:--:

# одно "двоеточие уровня", далее ключ " ", затем "разделяющее двоеточие", затем значение " : :"
   : : : :
```
## Пример нескольких уровней вложенности массива

Закодируем в HELML такой JSON-объект:
```json
{
	"A": "123",
	"B": {
		"X": "456",
		"Y": "789",
		"Z": {
			"One": 1,
			"Two": "2"
		},
		"C": "888"
	},
	"D": "111"
}
```
Результат:
```sh
A: 123

B:
  :X: 456
  :Y: 789

  :Z:
    ::One:  1
    ::Two: 2
  :C: 888
D: 111
```

Обратите внимание:
 - количество "двоеточий уровня" в начале строки всегда соответствует уровню вложенности элементов массива.
 - кодировщик HELML добавил отступы, пустые строки и знаки # в конце вложенных структур - это ничего не значит для парсера, но удобно для визуального восприятия
 - разумеется, добавление этих символов, предназначенных для удобства визуального восприятия, можно выключить

# Явное создание вложенных массивов

Чтобы создать новый (более глубокий) уровень вложенности, надо указать "ключ" и пустое "значение".

Этот "ключ" станет именем созданного под-массива, в который будут помещаться вложенные элементы.

####  ***`Заметим, что выше была изложена основная концепция HELML, и далее речь будет идти о нюансах`***

Рассмотрим пример НЕ правильного описания структуры:

```sh
A: 123
 :B: 456
  ::C: 789
```
В этом примере значения для ключей B и C попадут туда же, куда и A, не смотря на отступы и двоеточия.
Потому что в этом примере нет создания вложенных массивов.
Простое увеличение количества отступов и "двоеточий уровня" не влечёт повышения уровня вложенности.
Лишние "двоеточия уровня" игнорируются.

Результат декодирования HELML в данном примере будет такой:

```json
{
	"A": "123",
	"B": "456",
	"C": "789"
}
```
Количество "двоеточий уровня" имеет значение только тогда, когда оно меньше текущего уровня вложенности.
В таком случае указатель записи возвращается на тот уровень вложенности, который будет соответствовать
указанному количеству "двоеточий уровня".

# Два вида вложенных массивов

Вложенные массивы создаются указанием "ключа" и пустого значения, и здесь возможны два варианта:
  1) ключ и "разделяющее двоеточие", после которого нет значения.
  2) ключ без "разделяющего двоеточия" (в этом случае пустое значение подразумевается)
  
 - Когда "разделяющее двоеточие" завершает строку, создаётся массив с произвольными ключами `{...}`
 - Когда "разделяющее двоеточие" отсутствует, создаётся массив с числовыми ключами `[...]`
 
Различать эти два вида массивов удобно для совместимости, поскольку во многих языках программирования
по-разному реализуется работа со "словарями" и "списками".

В JSON, JavaScript, Python, "списки" (list) обычно записываются в квадратных скобках, например
`[123, 456, 789]`, а массивы с произвольными ключами ("словари", dict) записываются в фигурных скобках, например,
`{"A": 123, "B": 456}`.
Для сохранения типизации HELML позволяет отличать списки вида `[...]` от массивов вида `{...}`.
При создании ключа для вложенного массива к его имени добавляется двоеточие, чтобы указать массив вида `{...}`

Например, конвертируем этот JSON в HELML:
```json
{ "List": ["A","B","C"] }
```

В HELML это будет с двоеточием после "List":
```python
## Обратим внимание на отсутствие : после List, оно указывает, что это будет список с числовыми ключами
List
 :0: A
 :1: B
 :2: C
```
Если добавить двоеточие после "list", то массив будет раскодироваться так:
```json
{"List": {"0": "A", "1": "B", "2": "C"}}
```

Таким образом, в HELML двоеточия после ключа в конце строки позволяет создавать массивы с произвольными ключами,
и этот метод рекомендуется использовать в большинстве случаев. Второй вариант, когда двоеточия в после ключа нет,
создаёт массив с таким ограничением, что ключи в нём должны быть числовыми.

Для списков HELML удобен особый ключ "следующий номер", он позволяет записать приведённый выше пример так:

```sh
List
 :--: A
 :--: B
 :--: C
```

# Особые ключи

* Если в начале ключа нет знака "-", то это означает простой случай и такой "ключ" трактуется "как есть".
* Если в начале ключа есть знак "-", это указывает на особый ключ.

### Список особых ключей:
- Особый ключ "`--`" соответствует значению "следующий номер".
- Особый ключ "`-+`" позволяет изменять слой массива (см. ["многослойные массивы"](https://github.com/dynoser/HELML/blob/master/docs/MultiLayerArrays_ru.md))
- Особый ключ "`-++`" тоже относятся к многослойности (см. предыдущий пункт).
- Все прочие варианты ключей, начинающиеся на "-", декодируются из Base64 (base64url).

## Кодировка base64url

Различие между классической кодировкой Base64 и модификацией "url-safe" (base64url) состоит в том,
что в url-варианте символы "`+`" и "`/`" заменяются на "`-`" и "`_`", а знаки "`=`" в конце отбрасываются.

Эта разновидность кодировки Base64 обычно используется для передачи данных в строке URL.

Используемый в HELML раскодировщик base64url является более универсальным по сравнению со стандартным base64,
поскольку может декодировать как обычный base64, так и модифицированный.

Поэтому ключи и значения в формате Base64 можно кодировать и в обычном base64 режиме, и в base64url-модификации.

Заметим, что используемые в HELML особые ключи `--`, `-+`, `-++`, корректны для декодирования из base64url,
но они никогда не получаются при корректном кодировании. Поэтому особые ключи не пересекаются с закодированными.

# Ключ "следующий номер"

Если ключ имеет значение "`--`", то такой ключ автоматически получает "следующий номер",
равный текущему количеству элементов во вложенном массиве, в который идёт запись.
Это позволяет не указывать номера ключей явным образом, и особенно удобно для списков.

Пример:
```console
--
 :--: X
 :--: Y
--:
 :A
  ::--:  1
  ::--:  2
 :B:
  ::--: 3
  ::--: 4
 :-
  ::--: ABC
  ::--: DEF
```
Конвертируем из HELML в JSON:
```json
{
	"0": ["X", "Y"],
	"1": {
		"A": [1, 2],
		"B": {
			"0": "3",
			"1": "4"
		},
		"": {"0": "ABC", "1": "DEF" }
	}
}
```
Обратите внимание:
  * корневой уровень массива всегда считается "словарём", а не "списком".
  * для ключа "следующий номер" не имеет значения, идёт запись в словарь или в список.
  * в этом примере есть ключ `:-:` который означает ключ "пустая строка".
Это частный случай Base64: после знака "`-`" идёт пустая строка, что в кодировке Base64 означает пустую строку.

# Повторяющиеся ключи

Повторное появление ключа (то есть появление ключа с таким же именем) влечёт его перезапись.
Старое значение забывается и заменяется новым.

Например, в этом коде сначала задаётся массива A, и затем заменяется строковым значением "Three".
```console
A
:1: One
:2: Two
A: Three
```
Повторные ключи важны для концепции многослойности, это позволяет перезаписывать значения в зависимости от выборки слоёв.

# Кодировка значений

* Простые случаи - когда значение подходит для подстановки в формат "ключ: значение".
  В простых случаях, которых большинство, значения представляются "как есть".

* Особые случаи - когда значение особенное (например, содержит бинарные данные), или имеет не-строковой тип.

# Количество пробелов в начале значения - важно

Количество пробелов после "разделяющего двоеточия" (перед значением) позволяет различать варианты кодирования значения.
Различаются три варианта количества пробелов: 0, 1 и 2.

- Если между "разбивающим двоеточием" и значением стоит один пробел, это "простой случай".
  в этом случае "значение" возвращается просто "как есть"
- Если пробела нет, или пробелов два (или более), это "особые случаи" значений.
  Рассмотрим их подробнее

### Особые случаи значений:

! Количество пробелов после «разделяющего двоеточия» важно,
поскольку это указывает на особые случаи кодирования значений.

- Если пробела в начале значения нет, то:
  - если значение начинается с двойных или одинарных кавычек, это "случаи кавычек".
    - если кавычки одинарные, то возвращается значение внутри них, а кавычки отбрасываются.
    - если кавычки двойные, то возвращается значение с парсингом спец-символов (таких как `"\n"`)
  - если это знак "-", то значение предполагается закодированным в Base64
    - если это значение будет успешно раскодировано из Base64, будет возвращено раскодированное значение.
    - если значение не удаётся раскодировать, то будет возвращено значение `null`.
  - все остальные вараинты будут переданы пользовательскому обработчику CUSTOM_FORMAT_DECODER
  - если обработчик CUSTOM_FORMAT_DECODER отсутствует, то такое значение будет раскодироваться из base64.

- Если пробелов в начале значения два, то:
  - если после двух пробелов следует число, то оно будет представлено в числовом типе, а не строковом.
    - если число не содержит точку, оно будет представлено как integer
    - если число содержит в себе точку, оно будет представлено как float (double)
  - если после двух пробелов следует:
    - T - будет представлено как boolean-значение True
    - F - будет представлено как boolean-значение False
    - N - будет представлено как "отсутствие" NULL, или None, в зависимости от языка результата
    - NAN - будет представлено как числовое значение NaN (Not-A-Number, не число)
    - INF - будет представлено как числовое значение Infinity (бесконечность)
    - NIF - будет представлено как числовое значение -Infinity (минус бесконечность)
    - U - будет представлено как "undefined" на JavaScript, либо аналогично N на других языках
  - если значение после двух пробелов не соответствует вариантам, описанным выше, то:
    - для таких значений может быть задан пользовательский обработчик CUSTOM_FORMAT_DECODER
    - если пользовательский декодер не задан, то значение будет возвращено "как есть" (без двух пробелов)

```python
#Например, в зависимости от количества пробелов, 123 будет представлено как число, или как строка:
A: 123
A:  123
# если один пробел, значит 123 будет возвращено как строка, если два, то будет возвращено как число integer
```

## Значения в кавычках

Вариант с указанием строки в кавычках имеет смысл тогда, когда:
  - когда надо явно задать значение "пустая строка".
  - когда в значении важны пробелы по краям
  - двойные кавычки позволяют указать спец.символы в слэш-формате, вместо упаковки в Base64

```python
  # указание пустой строки в качестве значения:
    Test:""

	# пробелы в начале и конце будут сохранены, а кавычки отброшены:
  Hello:"  Hello World "

  # результат будет такой же, как в предыдущем варианте:
  Hello:'  Hello World '
  # результатом будет строка вместе с кавычками, то есть кавычки НЕ будут отброшены.
  # потому что пробел после двоеточия указывает на "простой случай", и данные возвращаются "как есть":
   Hello: " Hello World "

  # Здесь значение будет с символом перевода строки внутри, а двойные кавычки будут отброшены:
  Hello:"  Hello\n World  "
  # Здесь значение "\n" не будет преобразовано в символ перевода строки, данные вернутся как есть, но без кавычек:
    Hello:'  Hello\n World  '
```

# Многострочный и однострочный HELML

## Спецсимвол `~` = "перевод строки"

Специальный символ `~` парсер заменяет символом "перевод строки".
Иными словами, символ `~` в HELML можно использовать вместо символа "перевод строки".

Использование символа `~` вместо "перевода строки" позволяет "склеить" HELML в одну строку.
Давайте назовём это "однострочный HELML".

Однострочный HELML хорош когда неудобно использовать обычный "перевод строки".
Например, если надо поместить HELML-код в URL, или в аргумент команды, и т.д.

Это простейший способ передать в строковом параметре массив с сохранением его структуры и типов данных.

## Дополнительные роли спецсимвола `~`

Спецсимвол `~` имеет следующие дополнительные возможности:

### Префикс HELML-кодировки

Когда в тексте используется одновременно несколько языков разметки данных, важно иметь признак, позволяющий
быстро отличать интересующий формат от других. Это важно, например, для подстветки синтакиса.

Для этого рекомендуется добавлять знак `~` в начале HELML-разметки.
Это знак для синтаксических анализаторов, говорящий о том, что далее, возможно, находится HELML-разметка.

### Постфикс HELML-кодировки

Иногда требуется обозначить окончание HELML-разметки, и для этого есть постфикс: `~#: ~`

Постфик устроен так: между `~#` и `~` заключены два управляющих символа: двоеточие и пробел.
Эти символы могут быть заменены другими. Например, для кодировки URL удобно заменить их на "`.`" и "`=`",
поскольку преобразование "urlencode" (RFC 3986) их не изменяет. При такой замене постфикс будет: `~#.=~`.

Итак, конец HELML-разметки может обозначать либо `~#: ~`, либо `~#.=~` для однострочного URL-режима.

Все варианты HELML декодируются одним и тем же декодером.

# Итоги

* Формат HELML позволяет кодировать массивы произвольной структуры и затем раскодировать их обратно
с сохранением основных типов данных (integer, true, false, null, string, и некоторых других)

* HELML идеологически близок к JSON и YAML, предназначен для сериализации массивов и описания конфигураций.

* Главным преимуществом формата HELML является его простота и минимализм.

* Формат не спотыкается на бинарных данных и спецсимволах. Почти любой массив можно преобразовать в HELML,
затем перенести на другую платформу и там восстановить из HELML исходные данные.

* Формат интуитивно понятен, может легко создаваться и редактироваться вручную.

* HELML реализует ["концепцию многослойности"](https://github.com/dynoser/HELML/blob/master/docs/MultiLayerArrays_ru.md),
  которая позволяет получать значения, отличающиеся в зависимости от выборки слоёв.

* В большинстве случаев данные в HELML будут компактнее, чем в других языках разметки.