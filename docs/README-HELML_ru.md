# HELML

## HELML (Header-Like Markup Language)

![helml-logo](https://raw.githubusercontent.com/dynoser/HELML/master/logo/icon.png)

HELML (HEader-Like Markup Language) - это язык разметки, похожий на формат заголовков HTTP.

Например, можно этот текст декодировать из HELML:


```sh
Host: github.com
Accept: image/avif,image/webp
Accept-Encoding: gzip, deflate, br

```

В результате получится массив `[ключ] => 'значение'`:
```json
{
	"Host": "github.com",
	"Accept": "image/avif,image/webp",
	"Accept-Encoding": "gzip, deflate, br"
}
```

# Зачем?

## Когда не справляется JSON

Бывает, что нужна сериализация массивов, в которых встречаются бинарные данные.
Нельзя просто взять и сериализовать их JSON, потому что упаковщик JSON будет "спотыкаться" на некоторых данных.

Кроме того, стандартный JSON не позволяет добавлять комментарии.

Из-за этого приходится искать альтернативу для JSON, но другие форматы,
как правило, имеют неоправданно громоздкие парсеры и зависимости, и тянуть
их в свой проект не всегда рационально.

## HELML очень прост

Если надо сериализовать массив произвольной структуры и с любыми ключами и значениями внутри, то HELML это сделает быстро и надёжно.

Во многих случаях данные в формате HELML можно записывать не подключая
никакого кодировщика, а просто выводить строки данных вида "ключ: значение".

Данные в HELML можно передать на любую платформу и легко обработать на любом языке программирования. Кодирование и декодирование HELML выполняется очень простыми алгоритмами, которые лаконичны на любом языке программирования.

Данные в формате HELML легко создавать и редактировать вручную.

Давайте рассмотрим подробности формата HELML.

# Пустые строки и комментарии

- Пустые строки игнорируются.
- Пробелы по краям строк игнорируются (обрезаются и не имеют значения)
- Строки-комментарии начинаются со знака "`#`".
- Внутри-строчные комментарии не предусмотрены.

> 
    Можно добавлять сколько угодно пустых строк где угодно, они не важны.
    Пробелы по краям не важны, поэтому можно делать произвольные отступы.
    Можно закомментировать какие-то строки поставив # в начале строки.

# Использование Base64

Ключи и значения могут быть представлены в кодировке Base64.

Признаком закодированности в base64 является наличие в начале знака "-".

Например, четыре строки ниже в HELML означают одно и то же:
```python
# Простое представление ключ: значение
Host: github.com

# Ключ "Host" закодирован в base64
-SG9zdA: github.com

# Значение "github.com" закодировано в base64
# Обратите внимание, что "-" стоит сразу после двоеточия, без пробела.
Host:-Z2l0aHViLmNvbQ

# Ключ и значение закодированы в base64
-SG9zdA:-Z2l0aHViLmNvbQ
```

# Вложенные массивы

### Вложенностью массивов управляет знак "`:`" слева строки.

Количество двоеточий в начале строки соответствует уровню вложенности.

Сначала рассмотрим простой пример. Закодируем в HELML этот массив:
```json
{
	"Host": "github.com",
	"Names": {
		"first name": "github",
		"last name": "com"
	},
	"Family": "repos"
}
```
Результат:
```sh
Host: github.com
Names
 :first name: github
 :last name: com
Family: repos
```
В результате мы видим отступы слева у вложенных элементов.
Эти отступы состоят из пробелов и двоеточий. Однако, пробелы не важны,
они могут быть добавлены для удобства визуального восприятия.
Важно количество двоеточий, и оно должно соответствовать уровню вложенности.

Двоеточие - единственный символ (кроме разделителя строк), который управляет структурой массива.

1. Количество двоеточий в начале строки задаёт уровень вложенности. Это "**двоеточия уровня**".
2. За "двоеточиями уровня" всегда следует "ключ".
3. Следующее за ключом двоеточие либо отсутствует, либо присутствует. Это "**разделяющее двоеточие**".

Таким образом, любая строка HELML (кроме пустых и закомментированных) имеет следующий формат:

`[двоеточия уровня]ключ[:[значение]]`

Заметим, что строка всегда явным образом содержит "ключ".
Если "значение" не указано явно, оно подразумевается пустым.

Если есть "**двоеточия уровня**", то они должны следовать друг за другом без пробелов.
Появление любого иного символа означает завершение "**двоеточий уровня**" и начало "ключа".
Если после "двоеточий уровня" в строке есть ещё двоеточие, то это "**разделяющее двоеточие**",
которое разделяет "ключ" и "значение".

Если "**двоеточия уровня**" в начале строки отсутствуют, то они присуствуют в количестве 0,
и в таком случае речь идёт о корневом уровне массива. Это нулевой уровень вложенности.

Примеры, как понимаются двоеточия:
```python
# три "двоеточия уровня" и нет "разделяющего двоеточия"
:::X

# четыре "двоеточия уровня", затем ключ "X" и "разделяющее двоеточие", далее значение Y
 ::::X:Y

# одно "двоеточия уровня", затем ключ "AAA", затем "разделяющее двоеточие" и значение " BBB:CCC :DDD:"
:AAA: BBB:CCC :DDD:

# ноль "двоеточий уровня", затем ключ "X" и "разделяющее двоеточие", затем значение "Z"
    X:Z

# ноль "двоеточий уровня", затем ключ "This is a key", нет "разделяющего двоеточия"
This is a key

# одно "двоеточие уровня", далее ключ "--", затем "разделяющее двоеточие", затем пустое значение.
:--:

# одно "двоеточие уровня", далее ключ " ", затем "разделяющее двоеточие", затем значение " : :"
   : : : :
```
## Пример нескольких уровней вложенности массива

Закодируем в HELML такой массив:
```json
{
	"A": "123",
	"B": {
		"X": "456",
		"Y": "789",
		"Z": {
			"One": 1,
			"Two": "2"
		},
		"C": "888"
	},
	"D": "111"
}
```
Результат:
```sh
A: 123
B
 :X: 456
 :Y: 789
 :Z
  ::One:  1
  ::Two: 2
 :C: 888
D: 111
```
> 
  Обратите внимание, что количество "двоеточий уровня" в начале строки соответствует уровню вложенности элементов массива.

# Явное создание вложенных массивов

Чтобы создать новый (более глубокий) уровень вложенности, надо указать имя "ключ" и пустое "значение".

Этот "ключ" станет именем созданного под-массива, в который будут помещаться вложенные элементы.

Рассмотрим пример НЕ правильного подхода:
```sh
A: 123
 :B: 456
  ::C: 789
```
В этом примере значения для ключей B и C попадут туда же, куда и A, не смотря на отступы и двоеточия.
Потому что в этом примере нет создания вложенных массивов.
Простое увеличение количества отступов и "двоеточий уровня" не влечёт повышения уровня вложенности.
Лишние "двоеточия уровня" игнорируются.

Результат декодирования HELML в данном примере будет такой:
```json
{
	"A": "123",
	"B": "456",
	"C": "789"
}
```
Количество "двоеточий уровня" имеет значение только тогда, когда оно меньше текущего уровня вложенности.
В таком случае указатель записи возвращается на тот уровень вложенности, который будет соответствовать
указанному количеству "двоеточий уровня".

# Два вида вложенных массивов

Вложенные массивы создаются указанием "ключа" и пустого значения, и здесь возможны два варианта:
  1) ключ без "разделяющего двоеточия" (в этом случае пустое значение подразумевается)
  2) ключ и "разделяющее двоеточие", после которого нет значения и заканчивается строка

 - Когда "разделяющее двоеточие" отсутствует, создаётся массив с произвольными ключами `{...}`
 - Когда "разделяющее двоеточие" завершает строку, создаётся массив с числовыми ключами `[...]`

Различать эти два вида массивов есть смысл когда это важно для совместимости.
Например, для совместимости данных с форматом JSON, и с такими языками, как JavaScript, Python.
В этих случаях HELML позволит конкретизировать тип массива, "словарь" это или "список".

В JSON, JavaScript, Python, списки обычно записываются в квадратных скобках, например
`[123, 456, 789]`, а массивы с произвольными ключами записываются в фигурных скобках, например,
`{"A": 123, "B": 456}`. При конвертации таких данных в HELML эта типизация будет сохраняться.

Например, конвертируем этот JSON в HELML:
```json
{ "List": ["A","B","C"] }
```
В HELML это будет с двоеточием после "List":
```python
# Обратим внимание на : после List, оно указывает, что это будет список
List:
 :0: A
 :1: B
 :2: C
```
Если это двоеточие убрать, то такой массив будет раскодироваться так:
```json
{"List": {"0": "A", "1": "B", "2": "C"}}
```
Таким образом, в HELML добавление двоеточия после ключа в конце строки позволяет
указать, что создаётся вложенный массив типа "список", то есть ключи в нём должны
быть строго числовыми и последовательным от 0 и выше.

# Кодировка значений

- в простых случаях, которых большинство, значения кодируются так, как мы уже видели выше.
  
> 
    Простые случаи - когда значение подходит для подстановки в формат "ключ: значение".

    Особые случаи - когда значение особенное (например, бинарное), или имеет не-строковой тип.

- как уже отмечалось выше, значения в HELML всегда могут быть представлены в кодировке Base64 (или Base64url)
>
    *Различие между классической кодировкой Base64 и её модифицированным "url-safe" вариантом
    состоит в том, что в варианте "url-safe" символы "+" и "/" заменяются на "-" и "_",
    а знаки "=" в конце могут отбрасываться. Эта разновидность кодировки Base64 используется
    для более передачи данных в строке URL.*


# Количество пробелов в начале "значения" - важно

Количество пробелов после "разделяющего двоеточия" (перед значением) позволяет различать варианты кодирования значения.

- Если между "разбивающим двоеточием" и значением стоит один пробел, это "простой случай".
  в этом случае "значение" возвращается просто "как есть"
- Если пробела нет, или пробелов два и более, это "особые случаи" значений.
  Рассмотрим их подробнее
### Особые случаи значений:
- Если пробела в начале значения нет, то:
  - если значение начинается с двойных или одинарных кавычек, это "случаи кавычек".
    - если кавычки одинарные, то возвращается значение внутри них, а кавычки отбрасываются.
    - если кавычки двойные, то возвращается значение с парсингом спец-символов (таких как `"\n"`)
  - если это знак "-", то значение предполагается закодированным в Base64 (или Base64url)
    - если это значение будет успешно раскодировано из Base64, будет возвращено раскодированное значение.
    - если значение не удаётся раскодировать, то будет возвращено значение false.
  - все остальные вараинты будут переданы пользовательскому обработчику CUSTOM_FORMAT_DECODER
  - если обработчик CUSTOM_FORMAT_DECODER, то значение будет раскодироваться как base64.

- Если пробелов в начале значения два, то:
  - если после двух пробелов следует число, то оно будет представлено в числовом типе, а не как строка.
    - если число не содержит точку, оно будет представлено как integer
    - если число содержит в себе точку, оно будет представлено как float (double)
  - если после двух пробелов следует:
    - T - будет представлено как boolean-значение True
    - F - будет представлено как boolean-значение False
    - N - будет представлено как "отсутствие" NULL, или None, в зависимости от языка результата
    - NAN - будет представлено как числовое значение NaN (Not-A-Number, не число)
    - INF - будет представлено как числовое значение Infinity (бесконечность)
    - NIF - будет представлено как числовое значение -Infinity (минус бесконечность)
    - U - будет представлено как "undefined" на JavaScript, либо аналогично N на других языках
  - если значение после двух пробелов не соответствует вариантам, описанным выше, то:
    - для таких значений может быть задан пользовательский обработчик CUSTOM_FORMAT_DECODER
    - если пользовательский декодер не задан, то значение будет возвращено "как есть" (без двух пробелов) 

```python
#Например, в зависимости от количества пробелов, 123 будет представлено как число, или как строка:
A: 123
A:  123
# если один пробел, значит 123 будет возвращено как строка, если два, то будет возвращено как число integer
    
Вариант с указанием строки в кавычках имеет смысл тогда, когда:
  - когда надо явно задать значение "пустая строка".
  - когда в значении важны пробелы по краям
  - двойные кавычки позволяют указать спец.символы в слэш-формате, без упаковки значения в Base64

```python
    # указание пустой строки в качестве значения:
    Test:""

    # пробелы в начале и конце будут сохранены, а кавычки отброшены:
    Hello:"  Hello World "

    # результат будет такой же, как в предыдущем варианте:
    Hello:'  Hello World '

    # результатом будет строка вместе с кавычками, то есть кавычки НЕ будут отброшены.
    # потому что пробел после двоеточия указывает на "простой случай", и данные возвращаются "как есть":
    Hello: " Hello World "

    # Здесь значение будет с символом перевода строки внутри, а двойные кавычки будут отброшены:
    Hello:"  Hello\n World  "

    # Здесь значение "\n" не будет преобразовано в символ перевода строки, данные вернутся как есть, без кавычек:
    Hello:'  Hello\n World  '
```


# Особенные ключи

Если в начале ключа нет знака "-", то это означает простой случай и такой "ключ" трактуется "как есть".
Если в начале ключа есть знак "-", это означает особые случаи.

- Особый ключ "--" соответствует значению "следующий номер".
- Особый ключ "-+" позволяет изменять слой массива (см. "многослойные массивы")
- Все остальные варианты, начинающиеся на "-", декодируются из Base64 (base64url).

# Ключ "следующий номер"

Если ключ имеет значение "--", то такой ключ автоматически получает "следующий номер",
равный текущему количеству элементов во вложенном массиве, в который идёт запись.
Это позволяет не указывать номера ключей для списков.

*Такие ключи условно называются "BONE", потому что часто бывают похожи на кость :--:*

Пример с BONE-ключами:
```console
--
 :--: X
 :--: Y
--
 :A:
  ::--:  1
  ::--:  2
 :B:
  ::--: 3
  ::--: 4
 :-:
  ::--: ABC
  ::--: DEF
```
Этот HELML в формате JSON будет выглядеть так:
```json
{
	"0": "X",
	"1": "Y",
	"2": {
		"A": [
			1,
			2
		],
		"B": [
			"3",
			"4"
		],
		"": [
			"ABC",
			"DEF"
		]
	}
}
```
Обратите внимание, что в этом примере есть ключ :-: который преобразовался в ключ "пустая строка".
В данном случае ключ является частным случаем Base64, после знака "-" идёт пустая строка,
которая в кодировке Base64 тоже означает пустую строку.

# Повторяющиеся ключи

> 
    Q: -Что будет если один и тот же ключ встречается несколько раз?
    A: -Следующий ключ заменит предыдущий.

Повторное появление ключа влечёт его перезапись. Старое значение забывается и заменяется новым.
Например, в этом коде сначала задаётся массива A, и затем заменяется строковым значением "Three".
```console
A
:1: One
:2: Two
A: Three
```
Предполагается, что повторные ключи - либо результат ручного редактирования, либо это ошибка,
либо способ отменить данные, описанные выше, вместо того чтобы их закомментировать.

# Итоги

Формат HELML позволяет кодировать массивы произвольной структуры и затем раскодировать их обратно
с сохранением основных типов данных, таких как integer, true, false, null, string, и ряд других.

Этот формат идеологически близок к JSON и YAML, и предназначен для сериализации массивов
в тех случаях, когда это может быть более удобно.

Основным преимуществом формата HELML является его простота и минимализм.
Формат не спотыкается на бинарных данных и спецсимволах. Почти любой массив данных можно легко
преобразовать в HELML, перенести на другую платформу и там восстановить исходные данные обратно.

Формат интуитивно понятен, может легко создаваться и редактироваться вручную.
В большинстве случаев данные в HELML будут компактнее, чем в других языках разметки.

# URL-режим

Заменияем разделители строк на "~", управляющие двоеточия на точки ".", управляющие пробелы на нижнее подчёркивание "_",
и получаем одну строку, которая легко может быть использована как GET-параметр для URL, или как аргумент командной строки.
В таком виде HELML-формат визуально менее понятен, чем в многострочном формате, но зато очень компактно преобраозвывается "urlencode".
Выбор символов для замены обусловлен тем, что преобразование "urlencode" (RFC 3986) их не изменяет.
Возможно, это простейший способ передать в одной строке URL произвольный массив с сохранением его структуры и типизацией данных.
