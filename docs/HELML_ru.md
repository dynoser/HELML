# Спецификация HELML

## Управляющие символы:

 - `":"` - `LevelChar` - в начале строки обозначает уровень вложенности элементов, далее - разделяет `key` и `value`.
 - `" "` - `SpaceChar` - имеет значение перед `value` (т.е. после `key` и `LevelChar`). Позволяет отличать варианты кодировки значения.
 - `"-"` - `Base64Url` - наличие символа в начале `key` или `value` означает представление в кодировке в Base64url.
 - `"~"` - `AltNewLine` - заменяется на "\n". Альтернативный "перевод строки".

## Не значащие строки

 - Пустые строки и пробельные символы по краям строк не имеют значения и отбрасываются.
 - Если после отбрасывания пробельных символов в начале строки находится `#` (или `//`), то это строка-комментарий

## Значащие строки

Все строки HELML, кроме пустых и комментариев, мы назовём "значащие строки".

Такие строки содержат в себе `key` и `value`.

В значащей строке всегда явно присутствует `key`.

Значение `value` может быть не указано, и в этом случае подразумевается, что значение *формально пустое*.

Формат значащих строк HELML можно описать следующим регулярным выражением:

```javascript
/^(?P<level>\s*:*)\s*(?P<key>[^:\s]+)(?:\s*:\s*(?P<value>.*))?$/
```

## Смысл значащих строк

Каждая значащая строка записывает в текущий массив элемент с ключом `key` и значением, определённым в `value`.

Если значение `value` *формально пустое*, это означает создание массива следующего уровня вложенности.

Если в следующих строках идёт запись в созданный массив, это обозначается увеличением количества LevelChar в начале строки.

Количество LevelChar в начале строки должно соответствовать уровню вложенности массива, в который идёт запись.

Если количество LevelChar в строке уменьшилось (по сравнению со строками выше), то это означает окончание записи во вложенный массив и возврат к записи в массив предыдущего уровня.

## Корневой уровень массива

В начале декодирования HELML корневой уровень массива уже создан, и запись элементов идёт в него.

Все строки, у которых количество LevelChar равно 0 (т.е. символы LevelChar отсутствуют), ведут запись в корневой уровень массива.

## Ключи

Ключи всегда имеют тип "строка".

Поскольку ключ может быть представлен закодированным в Base64Url, строковое значение ключа может содержать любые символы.

Есть два варианта представления ключа:
 1. простой ключ (не начинаются с префикса `-`)
 2. особые ключи (начинаются с префика `-`)

### Простые ключи

Простыми являются все ключи без префикса `-`.
Они интерпретируются "как есть" (но пробелы по краям обрезаются).

### Особые ключи

Особыми являются все ключи с префиксом `-`. Наличие этого префикса всегда означает, что дальнейшие символы должны соответствовать кодировке Base64Url.

Существуют *специальные* ключи: это все комбинации из 1 или 2 символов `-` и `+` после префикса `-`. Такие ключи соответствуют Base64Url, но они никогда не получаются при корректном кодировании данных в Base64Url.

*специальные* ключи должны либо обрабатываться согласно их назначению.

Все особые ключи (кроме *специальных*, которые обрабатываются согласно их специальному назначению), должны декодироваться из Base64url.

### Специальный особый ключ "следующий номер"

Ключ "`--`" означает "*следующий номер в текущем массиве*". При декодировании такой ключ заменяется на строковое предствление числа, равного текущему количеству элементов в массиве, в который идёт запись.
 

### Поддержка специальных ключей в декодерах

Декодер HELML должен поддерживать специальный ключ `--` "следующий номер".
Поддержка остальных специальных ключей опциональна и зависит от реализации.

## Значения

Количество символов `SpaceChar` перед значением `value` либо равно 1, либо иное.

### Простое представление

Если количество символов `SpaceChar` перед `value` равно 1, то `value` трактуется "как есть" (пробелы по краям отбрасываюстя)

### Особые представления значений

Если количество символов `SpaceChar` перед `value` не равно 1, то это особые случаи кодирования `value`.

 - наличие префикса `"-"` перед значением `value` означает, что `value` это строка, закодированная в Base64Url
 - если `value` заключено в двойные или одинарные кавычки, они отбрасываются.
 - если `value` заключено в двойные кавычки, то дополнительно обрабатывается экранирование символов, как минимум для `\n`, `\r`, `\t`, `\0`, `\\`.
 - если `value` может быть интерпретировано как целое десятичное число, то оно получает числовой тип.
 - если `value` содержит знак "`.`"  и может быть интерпретировано как доробное число, то оно получает дробный тип.
 - если `value` имеет соответствие в таблице соответствий, то получается соответствующее значение. 
Таблица соответствий зависит от языка реализации.

Пример таблицы соответствий:

| from | to |
| :---: | --- |
| **T** | true |
| **F** | false |
| **N** | null |
| U | undefined |
| NAN | NaN |
| INF | Infinity |
| NIF | -Infinity |

 - если `value` не попало ни под какое из приведённых выше правил, оно либо декодируется пользовательским обработчиком, если он установлен, либо интерпретируется "как есть".

# Примеры

Массив в разметке HELML и затем он же в разметке JSON:

HELML:
```sh
One: 1
Two: Test
Subarray:
  :123: 456
  :Sub2:
    ::title: X-Y coordinates
    ::X-sub-key:  -774
    ::Y-sub-key:  888
  :yes:  T
  :not:  F
  :any:  N
X:  4444
Y:  55.66
Z:"Co\tOr\tDi\nNates"
Проверка: режим utf-8
```
JSON:
```json
{
	"One": "1",
	"Two": "Test",
	"Subarray": {
		"123": "456",
		"Sub2": {
			"title": "X-Y coordinates",
			"X-sub-key": -774,
			"Y-sub-key": 888
		},
		"yes": true,
		"not": false,
		"any": null
	},
	"X": 4444,
	"Y": 55.66,
	"Z": "Co\tOr\tDi\nNates",
	"Проверка": "режим utf-8"
}
```