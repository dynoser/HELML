# Спецификация HELML

## Управляющие символы:

 - `":"` - `LevelChar` - в начале строки обозначает уровень вложенности элементов, далее - разделяет `key` и `value`.
 - `" "` - `SpaceChar` - между `key` и `value` (то есть количество пробелов после `key:` и перед `value` ) - позволяет отличать варианты кодировки `value`.
 - `"-"` - `Base64` - в начале `key` или `value` этот символ означает представление в кодировке в Base64.
 - `"`\``"` - `Multiline` - апостроф в конце строки сразу после `key:` является признаком начала многострочного значения (окончание - один апостроф в строке).
 - `"~"` - `AltNewLine` - заменяется на "\n". Альтернативный "перевод строки".
## Не значащие строки и элементы

 - Пустые строки и пробельные символы по краям строк не имеют значения и отбрасываются.
 - Если после отбрасывания пробельных символов в начале строки находится знак `#` (или два знака `//`), то это строка-комментарий, не влияющая на результат.

## Значащие строки

Все строки, кроме пустых и комментариев, назовём "значащие строки".

Такие строки содержат в себе `key` и `value`. (*кроме случая `Mutliline`*)

В значащей строке всегда явно присутствует `key`.

Значение `value` может быть не указано, и в этом случае подразумевается, что значение *формально пустое*.

Формат значащих строк HELML можно описать следующим регулярным выражением:

```javascript
/^(?P<level>\s*:*)\s*(?P<key>[^:\s]+)(?:\s*:\s*(?P<value>.*))?$/
```

## Смысл значащих строк

Каждая значащая строка записывает в текущий массив элемент с ключом `key` и значением, определённым в `value`.

Если значение `value` *формально пустое*, это означает создание массива следующего уровня вложенности.

Если в следующих строках идёт запись в созданный массив, это обозначается увеличением количества LevelChar в начале строки (слева).

Количество LevelChar в начале строки (слева) всегда должно соответствовать уровню вложенности массива, в который идёт запись.

Если количество LevelChar в строке уменьшилось (по сравнению со строками выше), то это означает окончание записи во вложенный массив и возврат к записи в массив предыдущего уровня.

## Корневой уровень массива

В начале декодирования HELML корневой уровень массива уже создан, и запись элементов идёт в него.

Все строки, у которых количество LevelChar равно 0 (т.е. символы LevelChar отсутствуют), означают запись в корневой уровень массива.

## Ключи

Ключи всегда имеют тип "строка".

Поскольку ключ может быть представлен закодированным в Base64Url, строковое значение ключа может содержать любые символы.

Есть два варианта представления ключа:
 1. простой ключ (если **не** начинается с префикса `"-"`)
 2. особый ключ (если начинается с префика `"-"`)

### Простые ключи

Простыми являются все ключи без префикса `"-"`.
Они интерпретируются "как есть" (но пробелы по краям обрезаются).

### Особые ключи

Особыми являются все ключи с префиксом `-`. Наличие этого префикса означает, что дальнейшие символы должны соответствовать кодировке Base64Url.

Существуют *специальные* ключи: это все комбинации из 1 или 2 символов `-` и `+` после префикса `-`. Такие ключи тоже соответствуют Base64Url, но они никогда не получаются при корректном кодировании данных, и поэтому имеют особый смысл, о котором далее пойдет речь.

Все *специальные* ключи должны обрабатываться согласно их назначению, а все прочие особые ключи должны декодироваться из Base64url.

### Специальный особый ключ "следующий номер"

Ключ "`--`" означает "*следующий номер в текущем массиве*". При декодировании такой ключ заменяется на строковое предствление числа, равного текущему количеству элементов в массиве, в который идёт запись.
 

### Поддержка специальных ключей в декодерах

Декодер HELML должен поддерживать специальный ключ `--` "следующий номер".
Поддержка остальных специальных ключей опциональна и зависит от реализации.

## Значения

Количество символов `SpaceChar` перед значением `value` определяет формат кодирования `value`.

### Простое представление

Если количество символов `SpaceChar` перед `value` равно 1, то `value` трактуется "как есть" (пробелы по краям отбрасываюстя)

### Особые представления значений

Иное количество символов `SpaceChar` перед `value`, отличное от 1, указывает на иные варианты кодирования `value`.

Если перед `value` есть 0 символов `SpaceChar` (то есть эти символы отсутствуют), это указывает на префиксное кодирование `value`

 - префикс `"-"` означает, что `value` это строка, закодированная в Base64Url.
 - префикс `"%"` означает, что `value` это строка, закодированная в HEX-формате (поддержка HEX опциональна)
 - префикс `"` (двойная кавычка) означает, что это строка в кавычках, и в значении могут быть экранированные символы.
  (любой декодер должен поддерживать как минимум экранирование следующих вариантов:  `\n`, `\r`, `\t`, `\0`, `\\`)
 - префикс `'` (одинарная кавычка) означает строку без экранирования символов, декодер просто отбрасывает кавычки.

Если перед `value` есть 2 символа `SpaceChar`, это указывает на контентно-зависимое кодирование `value`:

 - если `value` имеет прямое соответствие в таблице соответствий, то заменяется соответствующим значением.
 - если `value` может быть интерпретировано как целое десятичное число, то оно получает числовой тип.
 - если `value` содержит знак "`.`"  и может быть интерпретировано как доробное число, то оно получает дробный тип.

Пример таблицы соответствий:

| from | to |
| :---: | --- |
| **T** | true |
| **F** | false |
| **N** | null |
| U | undefined |
| NAN | NaN |
| INF | Infinity |
| NIF | -Infinity |

- если `value` не попало ни под какое из приведённых выше правил, оно либо декодируется пользовательским обработчиком, если он установлен, либо интерпретируется "как есть".

# Примеры

Массив в разметке HELML и затем он же в разметке JSON:

HELML:
```sh
~
One: 1
Two: Test
Subarray:
  :123: 456
  :Sub2:
    ::title: X-Y coordinates
    ::X-sub-key:  -774
    ::Y-sub-key:  888
  :yes:  T
  :not:  F
  :any:  N
X:  4444
Y:  55.66
Z:"Co\tOr\tDi\nNates"
Проверка: режим utf-8
H:%0D0A7E
```
JSON:
```json
{
	"One": "1",
	"Two": "Test",
	"Subarray": {
		"123": "456",
		"Sub2": {
			"title": "X-Y coordinates",
			"X-sub-key": -774,
			"Y-sub-key": 888
		},
		"yes": true,
		"not": false,
		"any": null
	},
	"X": 4444,
	"Y": 55.66,
	"Z": "Co\tOr\tDi\nNates",
	"Проверка": "режим utf-8",
	"H": "\r\n~"
}
```