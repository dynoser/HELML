{"version":3,"file":"extension.js","mappings":"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","sources":["../.././src/HELML.ts","../.././src/extension.ts","../.././src/phparr.ts","../.././src/pythonarr.ts","../../external commonjs \"vscode\"","../../webpack/bootstrap","../../webpack/startup"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass HELML {\n    static encode(arr, url_mode = false) {\n        let results_arr = [];\n        // Check arr and convert to iterable (if possible)\n        arr = HELML.iterablize(arr);\n        let str_imp = url_mode ? \"~\" : \"\\n\";\n        let lvl_ch = url_mode ? '.' : ':';\n        let spc_ch = url_mode ? '_' : ' ';\n        // is the object a list with sequential keys?\n        let is_list = Array.isArray(arr);\n        if (!is_list && HELML.ENABLE_BONES) {\n            const keys = Object.keys(arr);\n            const expectedNumKeys = Array.from({ length: keys.length }, (_, i) => String(i));\n            is_list = keys.every((key, index) => key === expectedNumKeys[index]);\n        }\n        HELML._encode(arr, results_arr, 0, lvl_ch, spc_ch, is_list);\n        if (url_mode && results_arr.length == 1) {\n            results_arr.push('');\n        }\n        return results_arr.join(str_imp);\n    }\n    static _encode(arr, results_arr, level = 0, lvl_ch = \":\", spc_ch = \" \", is_list = false) {\n        // Set value encoder function as default valueEncoder or custom user function\n        const valueEncoFun = HELML.CUSTOM_VALUE_ENCODER === null ? HELML.valueEncoder : HELML.CUSTOM_VALUE_ENCODER;\n        for (let key in arr) {\n            let value = arr[key];\n            if (is_list && HELML.ENABLE_BONES) {\n                key = '--';\n            }\n            else if (!is_list) {\n                // encode key in base64url if it contains unwanted characters\n                let fc = key.charAt(0);\n                let lc = key.charAt(key.length - 1);\n                if (key.indexOf(lvl_ch) !== -1 || key.indexOf('~') !== -1 || fc === '#' || fc === spc_ch || fc === ' ' || fc === '') {\n                    fc = \"-\";\n                }\n                if (fc === \"-\" || lc === spc_ch || lc === ' ' || !/^[ -~]+$/.test(key)) {\n                    // add \"-\" to the beginning of the key to indicate it's in base64url\n                    key = \"-\" + HELML.base64Uencode(key);\n                }\n            }\n            // add the appropriate number of colons to the left of the key, based on the current level\n            let ident = lvl_ch.repeat(level);\n            // add space-ident to the left of the key (if need)\n            if (HELML.ENABLE_SPC_IDENT && spc_ch === ' ') {\n                ident = spc_ch.repeat(level) + ident;\n            }\n            let is_arr = Array.isArray(value);\n            if (value !== null && (is_arr || typeof value === 'object')) {\n                // if the value is an array or iterable, call this function recursively and increase the level\n                if (HELML.ENABLE_KEY_UPLINES && spc_ch === ' ') {\n                    results_arr.push('');\n                }\n                results_arr.push(ident + (is_arr ? key + lvl_ch : key));\n                value = HELML.iterablize(value);\n                HELML._encode(value, results_arr, level + 1, lvl_ch, spc_ch, is_arr);\n                if (HELML.ENABLE_HASHSYMBOLS && spc_ch === ' ') {\n                    results_arr.push(' '.repeat(level) + '#');\n                }\n            }\n            else {\n                // if the value is not an array, run it through a value encoding function\n                value = valueEncoFun(value, spc_ch);\n                // add the key:value pair to the output\n                results_arr.push(ident + key + lvl_ch + value);\n            }\n        }\n    }\n    static decode(src_rows, layers_list = [0]) {\n        // Set value decoder function as default valueDecoder or custom user function\n        const valueDecoFun = HELML.CUSTOM_VALUE_DECODER === null ? HELML.valueDecoder : HELML.CUSTOM_VALUE_DECODER;\n        // If the input is an array, use it. Otherwise, split the input string into an array.\n        let layer_init = '0';\n        let layer_curr = layer_init;\n        let all_layers = new Set(['0']);\n        // convert all elements in layers_list to String type\n        layers_list.forEach((item, index) => {\n            if (typeof item === \"number\") {\n                layers_list[index] = item.toString();\n            }\n        });\n        let lvl_ch = ':';\n        let spc_ch = ' ';\n        let exploder_ch = \"\\n\";\n        for (exploder_ch of [\"\\n\", \"~\", \"\\r\"]) {\n            if (src_rows.indexOf(exploder_ch) !== -1) {\n                if (exploder_ch === \"~\") {\n                    lvl_ch = '.';\n                    spc_ch = '_';\n                }\n                break;\n            }\n        }\n        let str_arr = src_rows.split(exploder_ch);\n        // Initialize result array and stack for keeping track of current array nesting\n        let result = {};\n        let stack = [];\n        let min_level = -1;\n        // Loop through each line in the input array\n        for (let line of str_arr) {\n            line = line.trim();\n            // Skip empty lines and comment lines starting with '#'\n            if (!line.length || line.charAt(0) === '#')\n                continue;\n            // Calculate the level of nesting for the current line by counting the number of colons at the beginning\n            let level = 0;\n            while (line.charAt(level) === lvl_ch) {\n                level++;\n            }\n            // If the line has colons at the beginning, remove them from the line\n            if (level) {\n                line = line.substring(level);\n            }\n            // Split the line into a key and a value (or null if the line starts a new array)\n            const firstDiv = line.indexOf(lvl_ch);\n            let key = firstDiv === -1 ? line : line.substring(0, firstDiv);\n            let value = firstDiv === -1 ? null : line.substring(firstDiv + 1);\n            // check min_level\n            if (min_level < 0 || min_level > level) {\n                min_level = level;\n            }\n            // Remove keys from the stack if level decreased\n            let extra_keys_cnt = stack.length - (level - min_level);\n            if (extra_keys_cnt > 0) {\n                // removing extra keys from stack\n                while (stack.length && extra_keys_cnt--) {\n                    stack.pop();\n                }\n                layer_curr = layer_init;\n            }\n            // Find the parent element in the result array for the current key\n            let parent = result;\n            for (let parentKey of stack) {\n                parent = parent[parentKey];\n            }\n            // Decode the key if it starts with an equals sign\n            if (key.charAt(0) === '-') {\n                if (key === '--' || key === '---') {\n                    // Next number keys\n                    key = (typeof parent === 'object') ? String(Object.keys(parent).length) : '0';\n                }\n                else if (key.startsWith('-+')) {\n                    // Layer control keys\n                    if (value !== null) {\n                        value = value.trim();\n                    }\n                    if (key === '-++') {\n                        layer_init = value ? value : '0';\n                        layer_curr = layer_init;\n                    }\n                    else if (key === '-+') {\n                        if (value == null) {\n                            layer_curr = Number.isInteger(parseInt(layer_curr)) ? String(layer_curr + 1) : layer_init;\n                        }\n                        else {\n                            layer_curr = (value === '') ? layer_init : value;\n                        }\n                    }\n                    all_layers.add(layer_curr);\n                    continue;\n                }\n                else {\n                    let decoded_key = HELML.base64Udecode(key.substring(1));\n                    if (decoded_key !== null) {\n                        key = decoded_key;\n                    }\n                }\n            }\n            // If the value is null, start a new array and add it to the parent array\n            if (value === null || value === '') {\n                parent[key] = value === '' ? [] : {};\n                stack.push(key);\n                layer_curr = layer_init;\n            }\n            else if (layers_list.includes(layer_curr)) {\n                // Decode the value by current decoder function and add the key-value pair to the current array\n                parent[key] = valueDecoFun(value, spc_ch);\n            }\n        }\n        if (all_layers.size > 1) {\n            result['_layers'] = Array.from(all_layers);\n        }\n        // Return the result array\n        return result;\n    }\n    static valueEncoder(value, spc_ch = ' ') {\n        if (typeof value === 'string') {\n            let need_encode = value.indexOf('~') !== -1;\n            let reg_str;\n            if ('_' === spc_ch) {\n                // for url-mode: ASCII visible chars only\n                reg_str = /^[ -~]+$/;\n            }\n            else {\n                // utf-8 visible chars\n                reg_str = /^[\\u0020-\\u007E\\u00A0-\\u00FF\\u0100-\\u017F\\u0180-\\u024F\\u1E00-\\u1EFF]+$/;\n            }\n            if (need_encode || !reg_str.test(value)) {\n                // if the string contains special characters, encode it in base64\n                return \"-\" + HELML.base64Uencode(value);\n            }\n            else if (!value.length || spc_ch === value[0] || spc_ch === value.slice(-1) || /\\s/.test(value.slice(-1))) {\n                // for empty strings or those that have spaces at the beginning or end\n                return \"'\" + value + \"'\";\n            }\n            else {\n                // if the value is simple, just add one space at the beginning\n                return spc_ch + value;\n            }\n        }\n        else {\n            const type = typeof value;\n            switch (type) {\n                case 'boolean':\n                    value = (value ? 'T' : 'F');\n                    break;\n                case 'undefined':\n                    value = 'U';\n                    break;\n                case 'number':\n                    if (value === Infinity) {\n                        value = \"INF\";\n                    }\n                    else if (value === -Infinity) {\n                        value = \"NIF\";\n                    }\n                    else if (Number.isNaN(value)) {\n                        value = \"NAN\";\n                    }\n                    else if ('_' === spc_ch && !Number.isInteger(value)) {\n                        // for url-mode because dot-inside\n                        return \"-\" + HELML.base64Uencode(String(value));\n                    }\n                /* falls through */\n                case 'bigint':\n                    break;\n                case 'object':\n                    if (value === null) {\n                        value = 'N';\n                        break;\n                    }\n                default:\n                    throw new Error(`Cannot encode value of type ${type}`);\n            }\n        }\n        return spc_ch + spc_ch + value;\n    }\n    static valueDecoder(encodedValue, spc_ch = ' ') {\n        const fc = encodedValue.charAt(0);\n        if (spc_ch === fc) {\n            if (encodedValue.substring(0, 2) !== spc_ch + spc_ch) {\n                // if the string starts with only one space, return the string after it\n                return encodedValue.slice(1);\n            }\n            // if the string starts with two spaces, then it encodes a non-string value\n            let slicedValue = encodedValue.slice(2); // strip left spaces\n            if (slicedValue in HELML.SPEC_TYPE_VALUES) {\n                return HELML.SPEC_TYPE_VALUES[slicedValue];\n            }\n            if (/^-?\\d+(.\\d+)?$/.test(slicedValue)) {\n                // it's probably a numeric value\n                if (slicedValue.indexOf('.') !== -1) {\n                    // if there's a decimal point, it's a floating point number\n                    return parseFloat(slicedValue);\n                }\n                else {\n                    // if there's no decimal point, it's an integer\n                    return parseInt(slicedValue, 10);\n                }\n            }\n            // custom user-defined function\n            if (typeof HELML.CUSTOM_FORMAT_DECODER === 'function') {\n                return HELML.CUSTOM_FORMAT_DECODER(encodedValue, spc_ch);\n            }\n            return slicedValue;\n        }\n        else if ('\"' === fc || \"'\" === fc) { // it's likely that the string is enclosed in single or double quotes\n            encodedValue = encodedValue.slice(1, -1); // trim the presumed quotes at the edges\n            return (fc === '\"') ? HELML.stripcslashes(encodedValue) : encodedValue;\n        }\n        else if (\"-\" === fc) {\n            encodedValue = encodedValue.slice(1);\n        }\n        else if (typeof HELML.CUSTOM_FORMAT_DECODER === 'function') {\n            return HELML.CUSTOM_FORMAT_DECODER(encodedValue, spc_ch);\n        }\n        // if there are no spaces or quotes at the beginning, the value should be in base64\n        return HELML.base64Udecode(encodedValue);\n    }\n    static base64Uencode(str) {\n        let base64;\n        if (typeof Buffer !== 'undefined') {\n            base64 = Buffer.from(str, 'binary').toString('base64');\n        }\n        else if (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n            base64 = window.btoa(str);\n        }\n        else {\n            throw new Error('Not found me base64-encoder');\n        }\n        return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n    }\n    static base64Udecode(str) {\n        str = str.replace(/-/g, '+').replace(/_/g, '/');\n        while (str.length % 4) {\n            str += '=';\n        }\n        try {\n            let decoded;\n            if (typeof Buffer !== 'undefined') {\n                decoded = Buffer.from(str, 'base64').toString('binary');\n            }\n            else if (typeof window !== 'undefined' && typeof window.atob === 'function') {\n                decoded = window.atob(str);\n            }\n            else {\n                throw new Error('Not found base64-decoder');\n            }\n            return decoded;\n        }\n        catch (e) {\n            return null;\n        }\n    }\n    static iterablize(arr) {\n        if (typeof arr[Symbol.iterator] !== 'function') {\n            arr[Symbol.iterator] = function* () {\n                const entries = [];\n                for (const key in this) {\n                    if (this.hasOwnProperty(key)) {\n                        entries.push([key, this[key]]);\n                    }\n                }\n                yield* entries;\n            };\n            return arr;\n        }\n        else if (arr instanceof Set || arr instanceof Map) {\n            return Array.from(arr.values());\n        }\n        return arr;\n    }\n    static stripcslashes(str) {\n        const controlCharsMap = {\n            '\\\\n': '\\n',\n            '\\\\t': '\\t',\n            '\\\\r': '\\r',\n            '\\\\b': '\\b',\n            '\\\\f': '\\f',\n            '\\\\v': '\\v',\n            '\\\\0': '\\0',\n            '\\\\\\\\': '\\\\'\n        };\n        return str.replace(/\\\\(n|t|r|b|f|v|0|\\\\)/g, (match) => controlCharsMap[match]);\n    }\n}\nHELML.ENABLE_BONES = true; // For encode: enable use \"next\"-keys like :--:\nHELML.ENABLE_SPC_IDENT = true; // For encode: add space-indentation at begin of string\nHELML.ENABLE_KEY_UPLINES = true; // For encode: adding empty string before array-create-keys\nHELML.ENABLE_HASHSYMBOLS = true; // For encode: adding # after nested-blocks\nHELML.CUSTOM_FORMAT_DECODER = null;\nHELML.CUSTOM_VALUE_DECODER = null;\nHELML.CUSTOM_VALUE_ENCODER = null;\nHELML.SPEC_TYPE_VALUES = {\n    'N': null,\n    'U': undefined,\n    'T': true,\n    'F': false,\n    'NAN': NaN,\n    'INF': Infinity,\n    'NIF': -Infinity\n};\nexports.default = HELML;\n","\"use strict\";\n//import jsesc from './jsesc';\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HELMLfromJSON = exports.decodeJSONtry = exports.removeJSONcomments = exports.HELMLtoJSON = exports.HELMLtoPHP = exports.HELMLtoPython = exports.deactivate = exports.activate = void 0;\nconst vscode = __importStar(require(\"vscode\"));\nconst HELML_1 = __importDefault(require(\"./HELML\"));\nconst phparr_1 = __importDefault(require(\"./phparr\"));\nconst pythonarr_1 = __importDefault(require(\"./pythonarr\"));\nlet HELMLLayersList = ['0'];\nfunction reloadConfig(event = null) {\n    const config = vscode.workspace.getConfiguration('helml');\n    const extname = 'helml';\n    const enableident = config.get('enableident');\n    const enablebones = config.get('enablebones');\n    const enableuplines = config.get('enableuplines');\n    const enablehashsym = config.get('enablehashsym');\n    if (enableident !== undefined && enableident !== HELML_1.default.ENABLE_SPC_IDENT) {\n        config.update('enableident', enableident, true);\n        HELML_1.default.ENABLE_SPC_IDENT = enableident;\n    }\n    if (enablebones !== undefined && enablebones !== HELML_1.default.ENABLE_BONES) {\n        config.update('enablebones', enablebones, true);\n        HELML_1.default.ENABLE_BONES = enablebones;\n    }\n    if (enableuplines !== undefined && enableuplines !== HELML_1.default.ENABLE_KEY_UPLINES) {\n        config.update('enableuplines', enableuplines, true);\n        HELML_1.default.ENABLE_KEY_UPLINES = enableuplines;\n    }\n    if (enablehashsym !== undefined && enableuplines !== HELML_1.default.ENABLE_HASHSYMBOLS) {\n        config.update('enablehashsym', enablehashsym, true);\n        HELML_1.default.ENABLE_HASHSYMBOLS = enablehashsym;\n    }\n    if (event === null || event.affectsConfiguration(extname + '.getlayers')) {\n        const getlayers = config.get('getlayers');\n        if (getlayers) {\n            HELMLLayersList = [];\n            const layers = getlayers.split(',');\n            layers.forEach(layer => HELMLLayersList.push(layer.trim()));\n        }\n    }\n}\nreloadConfig();\n// Auto-update config on changes\nvscode.workspace.onDidChangeConfiguration(event => {\n    if (event.affectsConfiguration('helml')) {\n        reloadConfig(event);\n    }\n});\nfunction cre_conv_fn(converter_fn) {\n    return () => {\n        const editor = vscode.window.activeTextEditor;\n        if (!editor) {\n            return;\n        }\n        const { document, selection } = editor;\n        const sel_text = document.getText(selection);\n        if (!sel_text) {\n            vscode.window.showWarningMessage('No text selected!');\n            return;\n        }\n        const convertedText = converter_fn(sel_text);\n        if (convertedText) {\n            editor.edit(editBuilder => {\n                editBuilder.replace(selection, convertedText);\n            });\n        }\n    };\n}\nfunction activate(context) {\n    const cmdToJSON = vscode.commands.registerCommand('helml.toJSON', cre_conv_fn(HELMLtoJSON));\n    const cmdFromJSON = vscode.commands.registerCommand('helml.fromJSON', cre_conv_fn(HELMLfromJSON));\n    const cmdToPHP = vscode.commands.registerCommand('helml.toPHP', cre_conv_fn(HELMLtoPHP));\n    const cmdToPython = vscode.commands.registerCommand('helml.toPython', cre_conv_fn(HELMLtoPython));\n    //const cmdToJavaScript = vscode.commands.registerCommand('helml.toJavaScript', cre_conv_fn(HELMLtoJavaScript));\n    const cmdFromJsonDoc = vscode.commands.registerCommand('helml.fromJSONDoc', () => __awaiter(this, void 0, void 0, function* () {\n        const editor = vscode.window.activeTextEditor;\n        if (!editor) {\n            return;\n        }\n        const { document, selection } = editor;\n        let sel_text = document.getText(selection);\n        let wholeDocSel = !sel_text;\n        let docIsSaved = !document.isDirty;\n        let canCloseOld = wholeDocSel && docIsSaved;\n        if (sel_text) {\n            if (sel_text === document.getText()) {\n                wholeDocSel = true;\n            }\n        }\n        else {\n            sel_text = document.getText();\n        }\n        let newFile;\n        const convertedText = HELMLfromJSON(sel_text);\n        if (convertedText) {\n            let fileName = document.fileName;\n            newFile = yield vscode.workspace.openTextDocument({\n                content: convertedText,\n                language: 'helml',\n            });\n        }\n        vscode.window.showTextDocument(newFile);\n    }));\n    context.subscriptions.push(cmdToJSON);\n    context.subscriptions.push(cmdFromJsonDoc);\n    context.subscriptions.push(cmdFromJSON);\n    context.subscriptions.push(cmdToPHP);\n    context.subscriptions.push(cmdToPython);\n    //context.subscriptions.push(cmdToJavaSc);\n}\nexports.activate = activate;\nfunction deactivate() { }\nexports.deactivate = deactivate;\n// export function HELMLtoJavaScript(sel_text: string): string | null {\n//     try {\n//         const objArr = HELML.decode(sel_text);\n//         const code_str = jsesc(objArr, {\n//             'quotes': 'double',\n//             'compact': false,\n//             'indent': '\\t'\n//         });\n//         return code_str;\n//     } catch (e) {\n//         console.error(\"Error: failed to encode HELML to JavaScript code\", e);\n//         vscode.window.showErrorMessage('Failed to encode HELML to JavaScript!');\n//         return null;\n//     }\n// }\nfunction HELMLtoPython(sel_text) {\n    try {\n        const objArr = HELML_1.default.decode(sel_text, HELMLLayersList);\n        const code_str = pythonarr_1.default.toPythonArr(objArr, 1);\n        return code_str;\n    }\n    catch (e) {\n        console.error(\"Error: failed to encode HELML to Python code\", e);\n        vscode.window.showErrorMessage('Failed to encode HELML to Python code');\n        return null;\n    }\n}\nexports.HELMLtoPython = HELMLtoPython;\nfunction HELMLtoPHP(sel_text) {\n    try {\n        const objArr = HELML_1.default.decode(sel_text, HELMLLayersList);\n        const code_str = phparr_1.default.toPHParr(objArr, 1);\n        return code_str;\n    }\n    catch (e) {\n        console.error(\"Error: failed to encode HELML to PHP code\", e);\n        vscode.window.showErrorMessage('Failed to encode HELML to PHP code');\n        return null;\n    }\n}\nexports.HELMLtoPHP = HELMLtoPHP;\nfunction HELMLtoJSON(sel_text) {\n    try {\n        const objArr = HELML_1.default.decode(sel_text, HELMLLayersList);\n        const json_str = JSON.stringify(objArr, null, '\\t');\n        return json_str;\n    }\n    catch (e) {\n        console.error(\"Error: failed to encode HELML to JSON\", e);\n        vscode.window.showErrorMessage('Failed to encode HELML to JSON');\n        return null;\n    }\n}\nexports.HELMLtoJSON = HELMLtoJSON;\nfunction removeJSONcomments(json_str) {\n    //return json_str;\n    const re1 = /^(\\s*)\\/\\/.*$/gm; // remove comments from string-begin\n    const re2 = /\\/\\*[^*]*\\*+([^\\/*][^*]*\\*+)*\\//g; // remove comments from end\n    return json_str\n        .replace(re1, '')\n        .replace(re2, '');\n}\nexports.removeJSONcomments = removeJSONcomments;\nfunction decodeJSONtry(json_str) {\n    try {\n        return JSON.parse(json_str);\n    }\n    catch (e) {\n        return null;\n    }\n}\nexports.decodeJSONtry = decodeJSONtry;\nfunction HELMLfromJSON(sel_text) {\n    try {\n        // check selection text is from middle of the JSON\n        sel_text = sel_text.trim();\n        if (sel_text.startsWith('\"')) {\n            sel_text = '{' + sel_text;\n            if (sel_text.endsWith(\",\")) {\n                sel_text = sel_text.slice(0, -1);\n            }\n            sel_text += '}';\n        }\n        let objArr = decodeJSONtry(sel_text);\n        if (objArr === null) {\n            sel_text = removeJSONcomments(sel_text);\n            objArr = JSON.parse(sel_text);\n        }\n        const helml_str = HELML_1.default.encode(objArr);\n        return helml_str;\n    }\n    catch (e) {\n        vscode.window.showErrorMessage('Failed to decode JSON to HELML!');\n        return null;\n    }\n}\nexports.HELMLfromJSON = HELMLfromJSON;\n// Hover-controller block\nfunction parseLine(line, word) {\n    let result_str = null;\n    let key_str = \"key\";\n    let value_str = \" value\";\n    line = line.trim();\n    if (!line.length || line.charAt(0) === '#')\n        return null;\n    let lvl_ch = ':';\n    // Calculate the level of nesting\n    let level = 0;\n    while (line.charAt(level) === lvl_ch) {\n        level++;\n    }\n    // If the line has colons at the beginning, remove them from the line\n    if (level) {\n        line = line.substring(level);\n    }\n    // Split the line into a\n    const firstDiv = line.indexOf(lvl_ch);\n    let key = firstDiv === -1 ? line : line.substring(0, firstDiv);\n    let value = firstDiv === -1 ? null : line.substring(firstDiv + 1);\n    // check key by first char\n    if (key.charAt(0) === '-') {\n        if (key === '--') {\n            // The bone-key means \"next number\".\n            key_str = \"next\";\n            key = \"[NextNum]\";\n        }\n        else if (key.startsWith('-+')) {\n            if (value) {\n                return \"Layer: \" + value;\n            }\n            else {\n                return \"Layer Next\";\n            }\n        }\n        else {\n            key_str = \"-b64key\";\n            let decoded_key = HELML_1.default.base64Udecode(key.substring(1));\n            if (null === decoded_key) {\n                result_str = \"ERROR: encoded KEY contain illegal chars\";\n            }\n            else {\n                const printableRegex = /^[ -~]+$/;\n                if (printableRegex.test(decoded_key)) {\n                    key_str = `-b64key(<i>${decoded_key}</i>)`;\n                }\n            }\n        }\n    }\n    if (result_str === null) {\n        if (value === null) {\n            result_str = `Create [${key}] Array`;\n        }\n        else if (value === \"\") {\n            result_str = `Create [${key}] LIST`;\n        }\n        else if (value.startsWith(' ')) {\n            if (value.startsWith('  ')) {\n                value_str = \" value <i>(non-string)<i>\";\n            }\n        }\n        else if (value.charAt(0) === '-') {\n            value_str = \"-b64value\";\n            let decoded_value = HELML_1.default.base64Udecode(value.substring(1));\n            if (null === decoded_value) {\n                result_str = \"ERROR: encoded VALUE contain illegal chars\";\n            }\n            else {\n                value_str = `-b64=${decoded_value}`;\n            }\n        }\n        else {\n            value_str = \"UNKNOWN or USER-DEFINED VALUE\";\n        }\n    }\n    if (result_str === null) {\n        result_str = key_str + \":\" + value_str;\n    }\n    return result_str;\n}\nconst hoverProvider = {\n    provideHover(document, position) {\n        const line = document.lineAt(position);\n        const text = line.text;\n        const wordRange = document.getWordRangeAtPosition(position);\n        const word = document.getText(wordRange);\n        const parsedText = parseLine(text, word);\n        if (parsedText) {\n            return new vscode.Hover(parsedText);\n        }\n        return null;\n    }\n};\nvscode.languages.registerHoverProvider('helml', hoverProvider);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass phparr {\n    static toPHParr(data, space) {\n        // prepare spaces\n        if (typeof space === 'number') {\n            if (space > 10) {\n                space = 10;\n            }\n            space = ' '.repeat(space);\n        }\n        else {\n            space = space.slice(0, 10);\n        }\n        // prepare ident function\n        let indent = function (item) {\n            return space\n                ? item\n                    .split('\\n')\n                    .map(function (line) { return space + line; })\n                    .join('\\n')\n                : item;\n        };\n        let tpd = typeof data;\n        switch (true) {\n            case tpd === 'number':\n                if (Number.isNaN(data)) {\n                    return 'NAN';\n                }\n                else if (data === Infinity) {\n                    return 'INF';\n                }\n                else if (data === -Infinity) {\n                    return '-INF';\n                }\n            case tpd === 'string':\n            case tpd === 'boolean':\n            case data === null:\n                return JSON.stringify(data);\n            case Array.isArray(data):\n                return ''\n                    + (space ? '[\\n' : '[')\n                    + data\n                        .map(function (item) { return phparr.toPHParr(item, space); })\n                        .map(indent)\n                        .join(space ? ',\\n' : ',')\n                    + (space ? '\\n]' : ']');\n            case tpd === 'object' && !Array.isArray(data):\n                let items = [];\n                for (var k in data) {\n                    items.push(''\n                        + JSON.stringify(k)\n                        + (space ? ' => ' : '=>')\n                        + phparr.toPHParr(data[k], space));\n                }\n                return ''\n                    + (space ? '[\\n' : '[')\n                    + items\n                        .map(indent)\n                        .join(space ? ',\\n' : ',')\n                    + (space ? '\\n]' : ']');\n            default:\n                throw new Error('parse error');\n        }\n    }\n}\nexports.default = phparr;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass pythonarr {\n    static toPythonArr(data, indentLevel = 0) {\n        const indent = ' '.repeat(indentLevel * 2);\n        if (Array.isArray(data)) {\n            const items = data.map((item) => indent + '  ' + this.toPythonArr(item, indentLevel + 1)).join(',\\n');\n            return items ? '[\\n' + items + '\\n' + indent + ']' : '[]';\n        }\n        if (typeof data === 'object' && data !== null) {\n            const items = Object.entries(data)\n                .map(([key, value]) => `${indent}  ${JSON.stringify(key)}: ${this.toPythonArr(value, indentLevel + 1)}`)\n                .join(',\\n');\n            return items ? '{\\n' + items + '\\n' + indent + '}' : '{}';\n        }\n        // Special number types\n        if (Number.isNaN(data)) {\n            return 'float(\"nan\")';\n        }\n        else if (data === Infinity) {\n            return 'float(\"inf\")';\n        }\n        else if (data === -Infinity) {\n            return 'float(\"-inf\")';\n        }\n        else if (data === null) {\n            return 'None';\n        }\n        else if (data === true) {\n            return 'True';\n        }\n        else if (data === false) {\n            return 'False';\n        }\n        // number, string, boolean\n        return JSON.stringify(data);\n    }\n}\nexports.default = pythonarr;\n","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(112);\n"],"names":["Object","defineProperty","exports","value","HELML","static","arr","url_mode","results_arr","iterablize","str_imp","lvl_ch","spc_ch","is_list","Array","isArray","ENABLE_BONES","keys","expectedNumKeys","from","length","_","i","String","every","key","index","_encode","push","join","level","valueEncoFun","CUSTOM_VALUE_ENCODER","valueEncoder","fc","charAt","lc","indexOf","test","base64Uencode","ident","repeat","ENABLE_SPC_IDENT","is_arr","ENABLE_KEY_UPLINES","ENABLE_HASHSYMBOLS","src_rows","layers_list","valueDecoFun","CUSTOM_VALUE_DECODER","valueDecoder","layer_init","layer_curr","all_layers","Set","forEach","item","toString","exploder_ch","str_arr","split","result","stack","min_level","line","trim","substring","firstDiv","extra_keys_cnt","pop","parent","parentKey","startsWith","Number","isInteger","parseInt","add","decoded_key","base64Udecode","includes","size","reg_str","slice","type","Infinity","isNaN","Error","encodedValue","slicedValue","SPEC_TYPE_VALUES","parseFloat","CUSTOM_FORMAT_DECODER","stripcslashes","str","base64","Buffer","window","btoa","replace","decoded","atob","e","Symbol","iterator","entries","this","hasOwnProperty","Map","values","controlCharsMap","match","undefined","NaN","__createBinding","create","o","m","k","k2","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","__setModuleDefault","v","__importStar","mod","prototype","call","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","rejected","done","then","apply","__importDefault","HELMLfromJSON","decodeJSONtry","removeJSONcomments","HELMLtoJSON","HELMLtoPHP","HELMLtoPython","deactivate","activate","vscode","HELML_1","phparr_1","pythonarr_1","HELMLLayersList","reloadConfig","event","config","workspace","getConfiguration","enableident","enablebones","enableuplines","enablehashsym","default","update","affectsConfiguration","extname","getlayers","layer","cre_conv_fn","converter_fn","editor","activeTextEditor","document","selection","sel_text","getText","showWarningMessage","convertedText","edit","editBuilder","objArr","decode","toPythonArr","console","error","showErrorMessage","toPHParr","JSON","stringify","json_str","parse","endsWith","encode","onDidChangeConfiguration","context","cmdToJSON","commands","registerCommand","cmdFromJSON","cmdToPHP","cmdToPython","cmdFromJsonDoc","newFile","wholeDocSel","isDirty","fileName","openTextDocument","content","language","showTextDocument","subscriptions","hoverProvider","provideHover","position","text","lineAt","wordRange","getWordRangeAtPosition","parsedText","word","result_str","key_str","value_str","decoded_value","parseLine","Hover","languages","registerHoverProvider","phparr","data","space","indent","map","tpd","items","indentLevel","module","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}