# HELML

## HELML (Header-Like Markup Language)

![helml-logo](logo/icon.png)

HELML (HEader-Like Markup Language) - это язык разметки, похожий на формат заголовков HTTP.

Например, это в формате HELML:

```console
Host: github.com
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:109.0) Gecko/20100101 Firefox/110.0
Accept: image/avif,image/webp,*/*
Accept-Language: ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br
Referer: https://github.com/dynoser/HELML/README.md
```
Если декодировать этот текст через HELML.decode, получится массив `[ключ] => 'значение'`, примерно так:
```console
[
    'Host' => 'github.com',
    'User-Agent' => 'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:109.0) Gecko/20100101 Firefox/110.0',
...
]
```

# Пустые строки и комментарии

- Пустые строки игнорируются.
- Строки-комментарии начинаются со знака "`#`".
- Внутри строк комментарии не предусмотрены, закомментировать можно только всю строку.

> 
    Вы можете добавлять сколько угодно пустых строк где угодно, они не важны.
    Вы можете закомментировать какие-то строки поставив # в начале строки.



# Вложенные массивы

## Формат HELML поддерживает произвольную вложенность массивов.

### Структурой массива управляет символ двоеточие "`:`".

Это ключевой момент, рассмотрим его подробнее. Начнём с примера.

Закодируем в HELML этот JSON-массив:
```json
{
	"Host": "github.com",
	"Names": {
		"no_www": "github.com",
		"www": "www.github.com"
	},
	"Test": "The test"
}
```
Результат:
```console
Host: github.com
Names
:no_www: github.com
:www: www.github.com
Test: The test
```
## Как работает двоеточие "`:`"

Двоеточие - единственный символ (кроме разделителя строк), который управляет структурой массива.

1. Количество двоеточий в начале строки задаёт уровень вложенности. Назовём это "**двоеточия уровня**".
2. Следующее двоеточие либо отсутствует, либо присутствует. Назовём его "**разбивающее двоеточие**".

Если "**двоеточия уровня**" в начале строки отсутствуют, то значит они присуствуют в количестве 0.

- Если "разбивающее двоеточие" есть, то оно разбивает строку на "ключ" и "значение".
- Если же "разбивающее двоеточие" отсутствует, то это означает создание вложенного массива.
- Если "разбивающее двоеточие" присутствует, но "значение" пустое, это тоже означает создание вложенного массива.

> 
    В приведённом выше примере строка "Names" без двоеточий означает, что
    "двоеточия уровня" в ней присутствуют в количестве 0, а "разбивающее двоеточие" - отсутствует.
    В итоге эта строка означает создание под-массива в ключе с именем [Names].

## Пример с более глубокой вложенностью

Закодируем в HELML такой массив:
```json
{
	"A": "123",
	"B": {
		"X": "456",
		"Y": "789",
		"Z": {
			"One": "1",
			"Two": "2"
		},
		"C": "888"
	},
	"D": "111"
}
```

Результат:
```console
A: 123
B
:X: 456
:Y: 789
:Z
::One: 1
::Two: 2
:C: 888
D: 111
```

# Явное создание под-массивов

У вас может возникнуть вопрос: что будет, если написать, например, так:

```console
A: 123
:B: 456
::C: 789
```
- Вопрос: Куда попадут B и C ?
- Ответ: Они попадут туда же, куда и A, то есть в корневой уровень массива.

 Результат в этом примере будет такой:
```json
{
	"A": "123",
	"B": "456",
	"C": "789"
}
```
- Почему?
> 
    Потому что в этом примере нет создания ключей для под-массивов.
    Увеличение количества "двоеточий уровня" не влечёт создание под-массивов.
    Создание под-массивов должно быть явным.
    Иными словами, если количество "двоеточий уровня" больше, чем
     текущий уровень вложенности, то это не имеет значения (игнорируется).

    А вот если меньше - тогда это имеет значение.
    
    Фактически, количество "двоеточий уровня" говорит о том,
    возвращаем ли мы указатель записи назад, на предыдущие уровни вложенности.
    Если количество "двоеточий уровня" меньше, чем текущий уровень вложенности,
    тогда мы возвращаемся назад на уровень, который будет этому соответствовать.

# Два вида вложенных массивов

*(эта возможность является опциональной и нужна не во всех языках программировния)*

В некоторых языках программирования, а также в формате JSON, различают два вида массивов:
  1) одни записываются в формате `{ ключ: значение, ключ значение, ... }`
  2) другие - "списки", записываются в формате `[ значение, значение, значение ... ]`

Второй вариант, записываемый обычно в квадратных скобках, отличается от первого тем,
что "ключи" предполагаются числовыми (от 0 и выше), и поэтому их явно не указывают.

В формате HELML ключи всегда указываюся явно.

Однако, для сохранения типизации HELML позволяет отличать списки вида `[...]` от массивов вида `{...}`.
Для этого при создании ключа вложенного массива к его имени добавляется двоеточие.

Например, конвертируем этот JSON в HELML:
```json
{ "List": ["A","B","C"] }
```
В HELML это будет с двоеточием после "List":
```console
List:
:0: A
:1: B
:2: C
```
Если это двоеточие убрать, это будет соответствовать массиву в фигурных скобках:
```json
{ "List": {"0": "A", "1": "B", "2": "C"} }
```

Таким образом, в HELML явное создание ключа для вложенного массива имеет два варианта записи:

  1) запись без "разделяющего двоеточия" создаёт массивы "в фигурных скобках".
  2) запись с "разделяющим двоеточием" и пустым "значением" создаёт массивы "в квадратных скобках".


# Итоги по структуре

Выше мы описали всё, что касается управления структурой вложенности массивов.

Для совместимости с JSON и типизацией ряда языков программирования,

Поддерживаются два типов вложенных массивов: "списки" `[...]` и "словари" `{...}`.

Корневой уровень всегда предполагается в формате "словаря" `{...}`.

В большинстве случаев это различие двух типов вложенных массивов можно игнорировать.

Этих возможностей вполне достаточно для создания транспортабельных данных 
с целью передачи сложно структурированных массивов между разными языками программирования.


Перейдём к рассмотрению кодировки значений.

# Кодировка значений

- в простых случаях, которых большинство, значения кодируются так, как мы уже видели выше.
  
> 
    Простые случаи - когда значение подходит для подстановки в формат "ключ: значение".

    Особые случаи - когда значение особенное (например, бинарное), или если важно указать его тип.

- значения в HELML всегда может быть представлены в кодировке Base64 (а также Base64url)

>
    *Различие между классической кодировкой Base64 и её модифицированным "url-safe" вариантом
    состоит в том, что в варианте "url-safe" символы "+" и "/" заменяются на "-" и "_".
    кроме того, знаки "=" в конце могут отбрасываться. Эта разновидность Base64 используется
    для более эффективной передачи данных в строке URL. При раскодировке разновидность Base64-url
    распознаётся автоматически, поэтому не требуется явно указывать, Base64 это или Base64-url.*

## Признак Base64-кодирования значений
>
    Если пробел после "разбивающего двоеточия" отсутствует, то значение предполагается закодированным в Base64.
    Эти две строки эквивалентны:

    A: Test
    A:IFRlc3Q=
    # в данном случае "IFRlc3Q=" является строкой "Test" в кодировке Base64, а пробел отсутствует.

! Количество пробелов после "разбивающего двоеточия" важно,
  оно указывает на особые случаи кодировки значения.

- Если между "разбивающим двоеточием" и значением стоит один пробел, это "простой случай".
- Если пробела нет, или пробелов два и более, это "особые случаи".
- Если пробела нет, то:
  - если значение начинается с двойных или одинарных кавычек, это "случаи кавычек".
    - если кавычки одинарные, то возвращается значение внутри них, а кавычки отбрасываются.
    - если кавычки двойные, то возвращается значение с парсингом спец-символов (таких как `"\n"`)
  - если это не кавычки, то значение предполагается закодированным в Base64 (или Base64url)
    - если это значение будет успешно раскодировано из Base64, будет возвращено раскодированное значение.
    - если не удаётся раскодировать, то значение будет возвращено как есть (не рекомендуемый сценарий!)
- Если пробелов два, то это касается случаев строгой типизации:
  - если после двух пробелов следует число, то оно будет представлено как число, а не как строка.
    - если число содержит в себе точку, оно будет представлено как float (double)
    - если число не содержит точку, оно будет представлено как integer
  - если после двух пробелов следует:
    - T - будет представлено как boolean-значение True
    - F - будет представлено как boolean-значение False
    - N - будет представлено как "отсутствие" NULL, или None, в зависимости от языка результата
    - NaN - будет представлено как числовое значение NaN

>
    Например, в зависимости от количества пробелов, 123 будет представлено как число, или как строка:
    A: 123   -- если один пробел, значит 123 будет возвращено как строка
    A:  123  -- если два пробела, значит 123 будет возвращено как число integer
    
Вариант с указанием строки в кавычках имеет смысл тогда, когда:
  - когда в значении важны пробелы по краям
  - когда надо задать пустую строку. (простое отстутсвие значение трактуется как создание под-массива)
  - двойные кавычки позволяют указать спец.символы в слэш-формате, без упаковки значения в Base64

>
    # явное указание пустой строки в качестве значения:
    Test:""

    # здесь пробелы в начале и конце строки будут сохранены, а кавычки отброшены:
    Hello:"  Hello World "

    # здесь результат будет точно такой же, как в предыдущем варианте:
    Hello:'  Hello World '

    # здесь значением будет строка вместе с кавычками, кавычки не будут отброшены.
    # потому что пробел после двоеточия указывает на "простой случай", и данные возвращаются "как есть":
    Hello: " Hello World "

    # Здесь значение будет с символом перевода строки внутри, а двойные кавычки будут отброшены:
    Hello:"  Hello\n World  "

    # Здесь значение "\n" не будет преобразовано в символ перевода строки, данные вернутся как есть, без кавычек:
    Hello:'  Hello\n World  '



# Кодировка ключей

- Есть только два варианта кодировки ключей:
  1) либо простой "как есть",
  2) либо в Base64 (Base64url)
  
Признаком того, что ключ закодирован в Base64 (Base64url) является наличие знака "-" в начале.

Например:
>
    ABC: Test      -- то же самое, что и строка ниже
    -QUJD: Test    -- здесь "QUJD" это "ABC" в кодировке Base64, а знак "-" признак закодированности.


# Повторяющиеся ключи

> 
    Q: -Что будет если один и тот же ключ встречается несколько раз?
    A: -Следующий ключ заменит предыдущий.

Теоретически, можно бы было сделать возможность "дописывать" элементы к заданным ранее массивам.
Однако, такой подход создавал бы простор для неоднозначной трактовки кода.
Поэтому, по крайней мере в текущей реализации, повторное появление ключа всегда влечёт его перезапись.
Старое значение полностью забывается и заменяется на новое.
Например, в этом коде сначала задаётся массива A, и затем заменяется строковым значением "Three".
```console
A
:1:One
:2:Two
A: Three
```
Предполагается, что повторные ключи - результат ручного редактирования.
Либо это ошибка, либо это для того, чтобы отменить данные, описанные выше, вместо того чтобы их закомментировать.


# Итоги

Формат HELML позволяет кодировать массивы сколь угодно сложной структуры
и затем раскодировать их с сохранением основных типов данных (true, false, null, integer, string).

Этот формат идеологически близок к YAML, JSON, и других форматам сериализации массивов,
и предназначен для использования вместо них в некоторых случаях, когда это более удобно.

Основным преимуществом формата HELML является его простота и минимализм.
Формат не спотыкается на бинарных данных и спецсимволах. Можно взять любой массив данных и преобразовать в HELML, затем перенести на другую платформу и восстановить данные обратно, не сохранив типизацию.

В то же время формат интуитивно понятен, может легко создаваться и редактироваться вручную.
В большинстве случаев данные в HELML-формате будут компактнее, чем в других языках разметки.


# URL-режим

Заменияем разделители строк на "~", управляющие двоеточия на точки ".", управляющие пробелы на нижнее подчёркивание "_",
и получаем одну строку, которая легко может быть использована как GET-параметр для URL, или как аргумент командной строки.
В таком виде HELML-формат визуально менее понятен, чем в многострочном формате, но зато очень компактно преобраозвывается "urlencode".
Выбор символов для замены обусловлен тем, что преобразование "urlencode" (RFC 3986) их не изменяет.
Возможно, это простейший способ передать в одной строке URL произвольный массив с сохранением его структуры и типизацией данных.
