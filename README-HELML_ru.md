# HELML

## HELML (Header-Like Markup Language)

![helml-logo](logo/icon.png)

HELML (HEader-Like Markup Language) - это язык разметки, похожий на формат заголовков HTTP.

Например, это в формате HELML:

```console
Host: github.com
Accept: image/avif,image/webp,*/*
Accept-Encoding: gzip, deflate, br
```

Если декодировать это через HELML.decode, то получится массив `[ключ] => 'значение'`:
```json
{
	"Host": "github.com",
	"Accept": "image/avif,image/webp,*/*",
	"Accept-Encoding": "gzip, deflate, br"
}
```

# Зачем нужен HELML?

## HELML нужен когда не справляется JSON.

Формат JSON хорош если не требуется передавать бинарные данные.
Когда же нужна сериализация массивов, в которых встречаются бинарные данные,
нельзя их просто взять и преобразовать JSON. Стандартные JSON-библиотеки
"спотыкаются" на некоторых значениях, и об этом постоянно надо помнить.

Есть много других способы сериализации (BSON, YAML, XML, и т.д.), но они,
как правило, неоправданно громоздкие и создают избыточные зависимости.

## HELML предназначен решать такую задачу:

- сериализовать массив произвольной структуры и с любыми значениями, чтобы
передавать эти данные на любую платформу и обрабатывать на любом языке программирования.

Кодирование и декодирование HELML выполняется очень простыми алгоритмами,
которые достаточно лаконичны на любом языке программирования и работают быстро.

В то же время, данные в формате HELML легко создавать и редактировать вручную,
поэтому формат подходит для использования в большинстве случаев вместо YAML и JSON.


# Пустые строки и комментарии

- Пустые строки игнорируются.
- Пробелы по краям строк игнорируются (обрезаются и не имеют значения)
- Строки-комментарии начинаются со знака "`#`".
- Внутри-строчные комментарии не предусмотрены.

> 
    Можно добавлять сколько угодно пустых строк где угодно, они не важны.
    Пробелы по краям не важны, поэтому можно делать произвольные отступы.
    Можно закомментировать какие-то строки поставив # в начале строки.



# Вложенные массивы

### Структурой массива управляет двоеточие "`:`".

Например, закодируем в HELML этот JSON-массив:
```json
{
	"Host": "github.com",
	"Names": {
		"first name": "github",
		"last name": "com"
	},
	"Family": "repos"
}
```
Результат:
```console
Host: github.com
Names
:first name: github
:last name: com
Family: repos
```
Можно добавить отступы слева и комментарии, смысл не изменится:
```python
# имя домена
Host: github.com

# разбивка на уровни
Names
  :first name: github
  :last name: com

# какой-то ещё параметр
Family: repos
```

Главное, на что важно обратить внимание - это расстановка знаков ":".
Это символ управления структурой, рассмотрим это подробнее.

## Как работает двоеточие "`:`"

Двоеточие - единственный символ (кроме разделителя строк), который управляет структурой массива.

1. Количество двоеточий в начале строки задаёт уровень вложенности. Назовём их "**двоеточия уровня**".
2. Следующее двоеточие либо отсутствует, либо присутствует. Назовём его "**разбивающее двоеточие**".

Если "**двоеточия уровня**" в начале строки отсутствуют, то значит они присуствуют в количестве 0.

- Если "разбивающее двоеточие" есть, то оно разбивает строку на "ключ" и "значение".
- Если же "разбивающее двоеточие" отсутствует, то это означает создание вложенного массива.
- Если "разбивающее двоеточие" присутствует, но "значение" пустое, это тоже означает создание вложенного массива.

Примеры того, как понимаются двоеточия:
```python
# три "двоеточия уровня" и нет разбивющего двоеточия
:::X

# четыре "двоеточия уровня", затем разбивающее двоеточие
 ::::X:Y

# одно "двоеточия уровня", затем разбивающее двоеточие после AAA, дальнейшие двоеточия не имеют значения
:AAA: BBB:CCC :DDD:

# ноль "двоеточий уровня", затем разбивающее двоеточие (ключ "X" и значение "Z")
    X:Z

# ноль "двоеточий уровня", нет разбивающего двоеточия (значит есть только ключ "This is a key")
This is a key

# одно "двоеточие уровня", далее ключ "--" и разбивающее двоеточие (затем пустое значение)
:--:

# одно "двоеточие уровня", далее ключ " " и разбивающее двоеточие (за ним значение " : :")
   : : : :
```
## Пример нескольких уровней вложенности

Закодируем в HELML такой массив:
```json
{
	"A": "123",
	"B": {
		"X": "456",
		"Y": "789",
		"Z": {
			"One": 1,
			"Two": "2"
		},
		"C": "888"
	},
	"D": "111"
}
```
Результат:
```console
A: 123
B
:X: 456
:Y: 789
:Z
::One:  1
::Two: 2
:C: 888
D: 111
```

> 
  Обратите внимание, что количество "двоеточий уровня" соответствует уровню вложенности элементов массива.

# Явное создание под-массивов

Что будет, если написать так:

```console
A: 123
:B: 456
::C: 789
```
- Вопрос: Куда попадут B и C ?
- Ответ: Эти элементы попадут туда же, куда и A, то есть в корневой уровень массива.

 Результат здесь будет такой:
```json
{
	"A": "123",
	"B": "456",
	"C": "789"
}
```
- Почему?
> 
    Потому что в этом примере нет создания ключей для вложенных массивов.
    Увеличение количества "двоеточий уровня" не влечёт создание новых уровней вложенности.
    Создание вложенных массивов должно быть явным.
    Иначе говоря, если количество "двоеточий уровня" больше, чем
     текущий уровень вложенности, то это не имеет значения (игнорируется).

    А вот если меньше - тогда это имеет значение.
    
    Фактически, количество "двоеточий уровня" говорит о том,
    возвращаем ли мы указатель записи назад, на предыдущие уровни вложенности.
    Если количество "двоеточий уровня" меньше, чем текущий уровень вложенности,
    тогда мы возвращаемся назад на уровень, который будет этому соответствовать.

# Два вида вложенных массивов

В HELML различаются два вида массивов:
  1) массивы с произвольными ключами
  2) списки - такие массивы, в которых ключи имеют числовые значения 0, 1, 2, и т.д.

Второй вариант отличается от первого тем, что во многих языках списки являются
отдельным типом данных, и это необходимо учитывать для совместимости с ними.

Например, в JSON, JavaScript, Python, списки обычно записываются в квадратных скобках,
например `[123, 456, 789]`, тогда как массивы с произвольными ключами записываются
в фигурных скобка, например, `{"A": 123, "B": 456}`.

HELML тоже позволяет отличать списки (то есть массивы с последовательными числовыми
ключами) от массивов с произвольными ключами. Это отличие задаётся в момент создания
ключа для вложенного массива:
  - если "разбивающее двоеточие" отсутствует, то массив для такого ключа будет создан с произвольными ключами (аналогично `{...}`).
  - если "разбивающее двоеточие" присутсвует, но "значение" пустое, то для такого ключа создаётся "список" (аналогично `[...]`).

Например, конвертируем этот JSON в HELML:
```json
{ "List": ["A","B","C"] }
```
В HELML это будет с двоеточием после "List":
```python
# Обратим внимание на : после List, оно указывает, что это будет список
List:
:0: A
:1: B
:2: C
# Ключи в списке должны быть числовыми.
```
Если это двоеточие убрать, массив будет раскодироваться как "в фигурных скобках":
```json
{ "List": {"0": "A", "1": "B", "2": "C"} }
```

Таким образом, в HELML создание ключа для вложенного массива имеет два варианта:

  1) запись без "разделяющего двоеточия" создаёт произвольные массивы ("словари")
  2) запись с "разделяющим двоеточием" и пустым "значением" создаёт списки.


# Итоги по структуре

Выше мы описали всё, что касается управления структурой вложенности массивов.

Структура массива задаётся при помощи только двоеточия и разделения строк.

При создании вложенных массивов ключи для них указываются явно.

При этом можно создавать два типа вложенных массивов: "списки" `[...]` и "словари" `{...}`.

Далее рассмотрим кодировку значений и ключей.

# Кодировка значений

- в простых случаях, которых большинство, значения кодируются так, как мы уже видели выше.
  
> 
    Простые случаи - когда значение подходит для подстановки в формат "ключ: значение".

    Особые случаи - когда значение особенное (например, бинарное), или имеет не-строковой тип.

- значения в HELML всегда могут быть представлены в кодировке Base64 (или Base64url)

>
    *Различие между классической кодировкой Base64 и её модифицированным "url-safe" вариантом
    состоит в том, что в варианте "url-safe" символы "+" и "/" заменяются на "-" и "_",
    а знаки "=" в конце могут отбрасываться. Эта разновидность кодировки Base64 используется
    для более передачи данных в строке URL.*

## Признак Base64-кодирования значений

Если пробел после "разбивающего двоеточия" отсутствует, то значение предполагается в Base64.

Например, эти две строки эквивалентны:

```python
A: Test
A:IFRlc3Q=
# в данном случае "IFRlc3Q=" является строкой "Test" в кодировке Base64,
#  а пробел в начале значения отсутствует, что указывает на использование Base64.
```
! Количество пробелов после "разбивающего двоеточия" важно,
  оно указывает на особые случаи кодировки значения.

- Если между "разбивающим двоеточием" и значением стоит один пробел, это "простой случай".
- Если пробела нет, или пробелов два и более, это "особые случаи".

### Особые кодировки значений:
- Если пробела в начале значения нет, то:
  - если значение начинается с двойных или одинарных кавычек, это "случаи кавычек".
    - если кавычки одинарные, то возвращается значение внутри них, а кавычки отбрасываются.
    - если кавычки двойные, то возвращается значение с парсингом спец-символов (таких как `"\n"`)
  - если это не кавычки, то значение предполагается закодированным в Base64 (или Base64url)
    - если это значение будет успешно раскодировано из Base64, будет возвращено раскодированное значение.
    - если не удаётся раскодировать, то значение будет возвращено как есть (не рекомендуемый сценарий!)
- Если пробелов в начале значения два, то это касается случаев не-строковых типов данных:
  - если после двух пробелов следует число, то оно будет представлено как число, а не как строка.
    - если число содержит в себе точку, оно будет представлено как float (double)
    - если число не содержит точку, оно будет представлено как integer
  - если после двух пробелов следует:
    - T - будет представлено как boolean-значение True
    - F - будет представлено как boolean-значение False
    - N - будет представлено как "отсутствие" NULL, или None, в зависимости от языка результата
    - NAN - будет представлено как числовое значение NaN (Not-A-Number, не число)
    - INF - будет представлено как числовое значение Infinity (бесконечность)
    - NIF - будет представлено как числовое значение -Infinity (минус бесконечность)
    - U - будет представлено как "undefined" на JavaScript, либо аналогично N на других языках
  - если значение после двух пробелов не соответствует вариантам, описанным выше, то:
    - для таких значений может быть задан пользовательский обработчик CUSTOM_FORMAT_DECODER
    - если пользовательский декодер не задан, то значение будет возвращено "как есть" (без двух пробелов) 

>
    Например, в зависимости от количества пробелов, 123 будет представлено как число, или как строка:
    A: 123   -- если один пробел, значит 123 будет возвращено как строка
    A:  123  -- если два пробела, значит 123 будет возвращено как число integer
    
Вариант с указанием строки в кавычках имеет смысл тогда, когда:
  - когда надо задать пустую строку. (простое отстутсвие значение трактуется как создание вложенного массива)
  - когда в значении важны пробелы по краям
  - двойные кавычки позволяют указать спец.символы в слэш-формате, без упаковки значения в Base64

```python
    # указание пустой строки в качестве значения:
    Test:""

    # пробелы в начале и конце будут сохранены, а кавычки отброшены:
    Hello:"  Hello World "

    # результат будет такой же, как в предыдущем варианте:
    Hello:'  Hello World '

    # результатом будет строка вместе с кавычками, то есть кавычки НЕ будут отброшены.
    # потому что пробел после двоеточия указывает на "простой случай", и данные возвращаются "как есть":
    Hello: " Hello World "

    # Здесь значение будет с символом перевода строки внутри, а двойные кавычки будут отброшены:
    Hello:"  Hello\n World  "

    # Здесь значение "\n" не будет преобразовано в символ перевода строки, данные вернутся как есть, без кавычек:
    Hello:'  Hello\n World  '
```


# Кодировка ключей

- Варианты кодировки ключей:
  1) простой "как есть",
  2) в Base64 (Base64url)
  3) вариант "следующий номер"

Если в начале ключа нет знака "-", это означает простой случай и трактуется "как есть".
Признаком того, что ключ "не простой", является наличие в знака "-" в его начале.

Ключ "--" является исключением, и соответствует значению "следующий нормер".
Все остальные варианты на "-", декодируются из Base64 (base64url).

Пример:
```yaml
    # простой ключ ABC, поскольку знак "-" в его начале отсутствует
    ABC: Test
    # тот же ключ в кодировке Base64 ("QUJD" это "ABC" в Base64)
    -QUJD: Test
```
# Ключ "следующий номер"

Если ключ имеет значение "--", то такой ключ автоматически получит "следующий номер",
равный текущему количеству элементов во вложенном массиве, в который идёт запись.
Это позволяет не указывать номера ключей для списков.

*Такие ключи условно называются "BONE", потому что часто бывают похожи на кость :--:*

Пример с BONE-ключами:
```console
--
:--: X
:--: Y
--
:A:
::--:  1
::--:  2
:B:
::--: 3
::--: 4
:-:
::--: ABC
::--: DEF
```
Этот HELML в формате JSON будет выглядеть так:
```json
{
	"0": {
		"0": "X",
		"1": "Y"
	},
	"1": {
		"A": [1, 2],
		"B": ["3", "4"],
		"": [
			"ABC",
			"DEF"
		]
	}
}
```
Обратите внимание, что в этом примере есть ключ :-: который преобразовался в ключ "пустая строка".
В данном случае ключ представлен  как частный случай Base64, поскольку после знака "-" идёт
пустая строка, что в кодировке Base64 также представляет собой пустую строку.

# Повторяющиеся ключи

> 
    Q: -Что будет если один и тот же ключ встречается несколько раз?
    A: -Следующий ключ заменит предыдущий.

Теоретически, можно бы было сделать возможность "дописывать" элементы к заданным ранее массивам.
Однако, такой подход создавал бы простор для неоднозначной трактовки кода.
Поэтому, по крайней мере в текущей реализации, повторное появление ключа всегда влечёт его перезапись.
Старое значение полностью забывается и заменяется на новое.
Например, в этом коде сначала задаётся массива A, и затем заменяется строковым значением "Three".
```console
A
:1: One
:2: Two
A: Three
```
Предполагается, что повторные ключи - результат ручного редактирования.
Либо это ошибка, либо это для того, чтобы отменить данные, описанные выше, вместо того чтобы их закомментировать.


# Итоги

Формат HELML позволяет кодировать массивы сколь угодно сложной структуры
и затем раскодировать их с сохранением основных типов данных (true, false, null, integer, string).

Этот формат идеологически близок к YAML, JSON, и других форматам сериализации массивов,
и предназначен для использования вместо них в некоторых случаях, когда это более удобно.

Основным преимуществом формата HELML является его простота и минимализм.
Формат не спотыкается на бинарных данных и спецсимволах. Можно взять любой массив данных и преобразовать в HELML, затем перенести на другую платформу и восстановить данные обратно, не сохранив типизацию.

В то же время формат интуитивно понятен, может легко создаваться и редактироваться вручную.
В большинстве случаев данные в HELML-формате будут компактнее, чем в других языках разметки.


# URL-режим

Заменияем разделители строк на "~", управляющие двоеточия на точки ".", управляющие пробелы на нижнее подчёркивание "_",
и получаем одну строку, которая легко может быть использована как GET-параметр для URL, или как аргумент командной строки.
В таком виде HELML-формат визуально менее понятен, чем в многострочном формате, но зато очень компактно преобраозвывается "urlencode".
Выбор символов для замены обусловлен тем, что преобразование "urlencode" (RFC 3986) их не изменяет.
Возможно, это простейший способ передать в одной строке URL произвольный массив с сохранением его структуры и типизацией данных.


# Микро-описание

Двоеточие - единственный символ (кроме разделителя строк), который управляет структурой массива.
Количество двоеточий в начале строки задаёт уровень вложенности, это "двоеточия уровня".
За "двоеточиями уровня" следует "ключ", а затем двоеточие либо отсутствует, либо присутствует.
Назовём его "разбивающее двоеточие", оно разделяет "ключ" и "значение.
Если "двоеточия уровня" в начале строки отсутствуют, то значит они присуствуют в количестве 0.
Если "разбивающее двоеточие" отсутствует, либо если "значение" является пустой строкой, то это означает создание вложенного массива.
Иначе строка означает добавление одного элемента в текущий массив.
- Пустые строки игнорируются.
- Пробелы по краям строк игнорируются (обрезаются и не имеют значения)
- Строки-комментарии начинаются со знака "#".
- Внутри-строчные комментарии не предусмотрены.